// Tile Engine Script

String path; // path for the tilemaps
bool pause_lock;
short refresh_timer;
bool refresh_timer_called;
int session_id;

import bool skippy_frames;
import bool in_speech;
import int tileset_sprite;
import bool TENG_running;
import int mapwidth;
import int mapheight;
import int cam_scroll_x;
import int cam_scroll_y;
import bool use_lock;
import bool inv_lock;
import bool walkOn_lock;
import DrawingSurface *BackupSurface;
import DynamicSprite *Foreground; // Layer 2
import DynamicSprite *TileRaster;
import int size_tile_x, size_tile_y;
import int tile_offset_x, tile_offset_y;
import short tile_limit_x, tile_limit_y;
import int num_tiles_x, num_tiles_y;
import int tile_scrolling_edge_h, tile_scrolling_edge_v;
import ctile tile[NUM_MAX_TILES];
import ctile_set tile_set;
import ctile_sprites tile_sprites[NUM_MAX_SPRITES];
import int num_different_tiles;
import cpeople people[MAX_PEOPLE];
import short people_index;
import short itm_index;
import citems item[MAX_ITEMS];
import short platform_screen_limit;
import cplatforms platform[MAX_PLATFORMS];
import short pf_index;
import cwaypoint waypoint[MAX_WAYPOINTS];
import short wp_index;
import cWeapons weapon[eWLastWeapon];
import short t_object_id[MAX_ITEMS];
import short people_id[MAX_PEOPLE];
import short t_hotspot_id[MAX_HOTSPOTS];
import short t_hotspot_index;
import ct_hotspot t_hotspot[MAX_HOTSPOTS];
import bool frame_drop;
import bool topdown_mode;
import short game_cycle;

//*******************************************************************************
//* helpers
//*
//*******************************************************************************

int noloopcheck Readword(this File*) {  
  char c1 = this.ReadRawChar();
  char c2 = this.ReadRawChar();
  return c2*256+c1;
}

int total(int number) 
{
  if ( number > 0)  return number;
  else              return number*(-1);
}

float total_f(float number) 
{
  if ( number > 0.0)  return number;
  else              return number*(-1.0);
}


//*******************************************************************************
//* start
//* starts the engine
//*
//*******************************************************************************
static function TENG::start()
{
  gPlayerStats.Visible=true;
  TENG_running = true;
  Mouse.SetPosition(0, 0);
  if (ego_stats.s_mouseaiming){
    mouse.Mode = eModePointer;
    mouse.Visible = true;
  }  
}

//*******************************************************************************
//* stop
//* stops the engine
//*
//*******************************************************************************
static function TENG::stop()
{
  DrawingSurface *foregroundSurface = Foreground.GetDrawingSurface();
  foregroundSurface.Clear(COLOR_TRANSPARENT);
  foregroundSurface.Release();
  gPlayerStats.Visible=false;
  TENG_running = false;
}

//*******************************************************************************
//* set_topdown_mode
//*
//*******************************************************************************
static void TENG::set_topdown_mode(bool enabled) {
  topdown_mode = enabled;
  EGO.set_topdown_mode(enabled);
}


//*******************************************************************************
//* get_topdown_mode
//*
//*******************************************************************************
static bool TENG::is_topdown_mode() {
  return topdown_mode;
}

//*******************************************************************************
//* clean_up
//* Calls all clearing functions
//*
//*******************************************************************************
static bool TENG::clean_up()
{
  int i = 0;
	wp_index = 0;
  if (!TENG_running) {
    BULLET.clear_all_bullets();
    PEOPLE.clear_all_people();
    ITM.clear_all_items();
    PFORM.clear_all_platforms();
    HSP.clear_all_hotspots();
    TILES.clear_all_tiles();
    TILES.clear_tile_sprites();
    PARALLAX.clear_all();
    WPOINT.clear_all_waypoints();
		
    while (i <=tile_set.anisync_tile_cnt) {
      tile_set.anisync_tile_no[i]=0;
      i++;
    }
    tile_set.anisync_tile_cnt = 0;

    ego_stats.xspeed = 0;
    ego_stats.xaccel = 0;
    ego_stats.yspeed = 0;
    ego_stats.yaccel = 0;
    ego_stats.climb_speed = 0.0;
    ego_stats.Jump_Timer = 0;
    ego_stats.InSlide = 0;
    ego_stats.SlideTimer = 0;
    ego_stats.ShotTimer = 0;
    ego_stats.current_act_id = 0;
    ego_stats.current_action = 0;
    ego_stats.GrabPossible = false;
    ego_stats.anicounter_attack = -1;
    ego_stats.frame_attack = 0;
    ego_stats.invincible_timer = 0;
    ego_stats.invincible_cnt = 0;
    ego_stats.s_invincible =false;
    ego_stats.is_dying = false;
    ego_stats.is_dead = false;
    
    tile_offset_x = 0;
    tile_offset_y = 0;

    return true;
  }
  else Display("Can't clean up, engine is still runnning!");
}


//*******************************************************************************
//* new_map
//*
//*******************************************************************************
static bool TENG::new_map(int _tileset_sprite, int _num_tiles_x, int _num_tiles_y, int _size_tile_x, int _size_tile_y)
{
  tileset_sprite = _tileset_sprite;
	size_tile_x = _size_tile_x;
	size_tile_y = _size_tile_y;
	tile_offset_x = 0;
	tile_offset_y = 0; 
  num_tiles_x = _num_tiles_x;
  num_tiles_y = _num_tiles_y;
  mapwidth = num_tiles_x * size_tile_x;
  mapheight =  num_tiles_y * size_tile_y;
  int max_tile_spr_x = 0;
  int max_tile_spr_y = 0;
  
  int i, j, k, index;

  TILES.init_tile_sprites(tileset_sprite);
  
  i=0;
  j=0;
  k=0;
  
  //init Tiles
  while ( k < LAYERS ){
    while ( j < num_tiles_y ) {
      i = 0;
      while ( i < num_tiles_x ) {    
        TILES.clear_tile(index, k);

        tile[index].x[k] = i * size_tile_x;
        tile[index].y[k] = j * size_tile_y;
        index ++;
        i++;
      } 
      j++;
    }
    k++;
  }
 
  return true;
}

//*******************************************************************************
//* load_map
//*
//*******************************************************************************
static bool TENG::load_map (String filename, int _tile_scrolling_edge_h, int _tile_scrolling_edge_v, int custom_sprite_slot, bool use_savegamedir)
{
  int i, j, k, index;
  int bg_tile_count;
  int fg_tile_count;
  int waypoint_count;
  int platform_count;
  int item_count;
  int people_count;
  int hotspot_count;
  int max_tile_spr_x, max_tile_spr_y;
  int code;
  int tempsprite = 0;
  int temp_session =0;
  
  tile_scrolling_edge_h = _tile_scrolling_edge_h;
	tile_scrolling_edge_v = _tile_scrolling_edge_v;
  String levelname;
  i = 0;
  j = 0;
  k = 0;  
  
  if (use_savegamedir) levelname = "$SAVEGAMEDIR$/";
  else levelname = path; //Compiled/Tilemaps
  
  levelname = levelname.Append(filename);
  levelname = levelname.Append(".lvl");
  
  File *file = File.Open(levelname, eFileRead);
  if (file == null)	return false;
  
  // Read Map Header
  temp_session = file.ReadInt();
  tileset_sprite = file.ReadInt();
  num_different_tiles = file.ReadInt();
  if (custom_sprite_slot >0) tileset_sprite = custom_sprite_slot;
  
  size_tile_x = file.ReadInt();
  size_tile_y = file.ReadInt();
  num_tiles_x = file.ReadInt();
  num_tiles_y = file.ReadInt();
 
  mapwidth = num_tiles_x * size_tile_x;
  mapheight =  num_tiles_y * size_tile_y;
  // Read Player Spawn;
  ego_stats.startx = file.ReadInt();
  ego_stats.starty = file.ReadInt();

  // Load TileCodes  
  TILES.clear_tile_sprites();

  
  i = 0;
  while (i < num_different_tiles) { 
    tile_sprites[i].code = file.ReadInt();
    i++;
  }  
  TILES.init_tile_sprites(tileset_sprite);
  TILES.clear_all_tiles();
  
  // Load Background Tiles
  code = 0;
  i=0;
  j=0;
  index = 0; 
  bg_tile_count = file.ReadInt();

  while (i < bg_tile_count) {
    tempsprite = 0;
    index = file.ReadInt();
    tile[index].mirrored_x[0] = file.ReadInt();
    tile[index].mirrored_y[0] = file.ReadInt();
    tile[index].tileno[0] = file.ReadInt();
    
    if (tile_sprites[ tile[index].tileno[0] ].spr != null) 
      tempsprite =tile_sprites[ tile[index].tileno[0] ].spr.Graphic;
    
    if (tempsprite > 0 && Game.SpriteHeight[tempsprite]>0) {
      tile[index].spr[0] = DynamicSprite.CreateFromExistingSprite(tile_sprites[ tile[index].tileno[0] ].spr.Graphic, true);
    
      if (tile[index].mirrored_x[0] && tile[index].mirrored_y[0]) tile[index].spr[0].Flip(eFlipBoth);
      else if (tile[index].mirrored_x[0]) tile[index].spr[0].Flip(eFlipLeftToRight);
      else if (tile[index].mirrored_y[0]) tile[index].spr[0].Flip(eFlipUpsideDown);
    }

    code = tile_sprites[ tile[index].tileno[0] ].code;
    TILES.define_tiles(index, 0, code);    
    
    i++;
  }
    
  // Load Foreground Tiles
  code = 0;
  i=0;
  index = 0; 
  fg_tile_count = file.ReadInt();
  
  while (i < fg_tile_count) {
    tempsprite = 0;
    index = file.ReadInt();
    tile[index].mirrored_x[1] = file.ReadInt();
    tile[index].mirrored_y[1] = file.ReadInt();
    tile[index].tileno[1] = file.ReadInt();
    
    if (tile_sprites[ tile[index].tileno[1] ].spr != null) 
      tempsprite =tile_sprites[ tile[index].tileno[1] ].spr.Graphic;
    
    if (tempsprite > 0 && Game.SpriteHeight[tempsprite]>0) {
      tile[index].spr[1] = DynamicSprite.CreateFromExistingSprite(tile_sprites[ tile[index].tileno[1] ].spr.Graphic, true);
    
      if (tile[index].mirrored_x[1] && tile[index].mirrored_y[1]) tile[index].spr[1].Flip(eFlipBoth);
      else if (tile[index].mirrored_x[1]) tile[index].spr[1].Flip(eFlipLeftToRight);
      else if (tile[index].mirrored_y[1]) tile[index].spr[1].Flip(eFlipUpsideDown);
    }

    code = tile_sprites[ tile[index].tileno[1] ].code;
    TILES.define_tiles(index, 1, code);    
    
    i++;
  }  
  
  // Apply XY position for all tiles
  i=0;
  j=0;
  k=0;
  while ( k < LAYERS ){
    j = 0;
    index = 0;
    while ( j < num_tiles_y ) {
      i = 0;
      while ( i < num_tiles_x ) {
        tile[index].x[k] = TILES.getTileIndexXFromIndex(index) * size_tile_x;
        tile[index].y[k] = TILES.getTileIndexYFromIndex(index) * size_tile_y;               
        index ++;
        i++;
      } 
      j++;
    }
    k++;
  }
  index =0;
  i=0;
  j=0;
  k=1;
  
  // Load Waypoints
  waypoint_count = file.ReadInt();
  
  i=0;
  while (i<waypoint_count) {
    waypoint[i].x = file.ReadInt();
    waypoint[i].y = file.ReadInt();
    waypoint[i].nextDir = file.ReadInt();
    waypoint[i].active = true;
    wp_index++;
    i++;
  }
  
  // Load Platforms
  platform_count = file.ReadInt();
  i = 0;
  while (i<platform_count) {
    PFORM.clear_platform(i);
    int curtile  = file.ReadInt();
    int xspeed = file.ReadInt();
    if (xspeed >0) PFORM.create_platfrom(curtile, 1);
    else PFORM.create_platfrom(curtile, 2);
    i++;
  }
  
  // Load items and objects
  item_count = file.ReadInt();
  
  i=0;
    int itm_current_tile;
    int itm_type;
    int itm_loop;
    int itm_obj_id;
    int itm_obj_sprite;
    int itm_img;
    int itm_hidden;
    int itm_is_solid;
    int itm_usable;
    int itm_ignore_gravity;
    int itm_in_foreground;
    String itm_name;
    String itm_shown_name;
  
  while (i < item_count) {
    itm_current_tile = file.ReadInt();
    itm_type = file.ReadInt();
    itm_loop = file.ReadInt();
    itm_obj_id = file.ReadInt();
    itm_obj_sprite = file.ReadInt();
    itm_img = file.ReadInt();
    itm_hidden = file.ReadInt();
    itm_is_solid = file.ReadInt();
    itm_usable = file.ReadInt();
    itm_ignore_gravity = file.ReadInt();
    itm_in_foreground = file.ReadInt();
    itm_name = file.ReadStringBack();
    itm_shown_name = file.ReadStringBack();
    
    
    if (itm_obj_id < 1) {
      ITM.spawn_item(itm_current_tile, itm_loop, 0, itm_type, itm_hidden, false);
    }
    else {
      int obj_idx = ITM.spawn_object(itm_current_tile);
      item[ t_object_id[obj_idx] ].name = itm_name;
      item[ t_object_id[obj_idx] ].shown_name = itm_shown_name;
      item[ t_object_id[obj_idx] ].obj_sprite = itm_obj_sprite;
      item[ t_object_id[obj_idx] ].is_solid = itm_is_solid;
      item[ t_object_id[obj_idx] ].usable = itm_usable;
      item[ t_object_id[obj_idx] ].ignore_gravity = itm_ignore_gravity;
      item[ t_object_id[obj_idx] ].in_foreground  = itm_in_foreground;
      item[ t_object_id[obj_idx] ].img = itm_img;
      item[ t_object_id[obj_idx] ].hidden = itm_hidden;
    }  
    i++;
  }
 
  // Load People
  people_count = file.ReadInt();
  i=0;
  int ppl_type;
  int ppl_id;
  int ppl_current_tile;
  int ppl_view;
  int ppl_talk_view;
  int ppl_talk_color;
  int ppl_idle_view;
  int ppl_is_interactable;
  int ppl_is_hostile;
  int ppl_limit_left;
  int ppl_limit_right;
  int ppl_limit_up;
  int ppl_limit_down;
  String ppl_name;

  
  while (i < people_count ) {
    ppl_type = file.ReadInt();
    ppl_id = file.ReadInt();
    ppl_current_tile = file.ReadInt();
    ppl_view = file.ReadInt();
    ppl_talk_view = file.ReadInt();
    ppl_talk_color = file.ReadInt();
    ppl_idle_view = file.ReadInt();
    ppl_is_interactable = file.ReadInt();
    ppl_is_hostile  = file.ReadInt();
    
    ppl_limit_left  = file.ReadInt();
    ppl_limit_right = file.ReadInt();
    ppl_limit_up    = file.ReadInt();
    ppl_limit_down  = file.ReadInt();    
    
    ppl_name = file.ReadStringBack();
    
    if (ppl_type == ppl_custom) {
      int ret_ppl_idx = PEOPLE.spawn_npc(ppl_current_tile, ppl_name, ppl_view, ppl_talk_view, ppl_talk_color, ppl_idle_view);
      people[ret_ppl_idx].is_interactable = ppl_is_interactable;
      people[ret_ppl_idx].is_hostile = ppl_is_hostile;      
      people[ret_ppl_idx].dead_timer = -1;
    }
    else {
      int ret_ppl_idx = PEOPLE.spawn_enemy(ppl_current_tile, ppl_type);

    }
    
    i++;
  }
  
  // Load Hotspots
  hotspot_count = file.ReadInt();
  i=0;
  int temp_hsp_id;
  int hsp_x;
  int hsp_y;
  int hsp_id;
  int hsp_hidden;
  int hsp_img;
  String hsp_name;
  String hsp_shown_name;
  
  while (i<hotspot_count) {
    hsp_x = file.ReadInt();
    hsp_y = file.ReadInt();
    hsp_id = file.ReadInt();
    hsp_hidden = file.ReadInt();
    hsp_img = file.ReadInt();
    hsp_name = file.ReadStringBack();
    hsp_shown_name = file.ReadStringBack();
    
    temp_hsp_id = HSP.spawn_hotspot(-1, hsp_id, hsp_hidden, hsp_name, hsp_x, hsp_y);
    HSP.set_hotspot_shown_name(temp_hsp_id, hsp_shown_name);
    i++;
  }
  
  // Close and finish
  file.Close();
  
  int temp_x = ego_stats.startx * size_tile_x;
  int temp_y = ego_stats.starty * size_tile_y;
  player.x = temp_x + ( size_tile_x / 2 ) + tile_offset_x;
  player.y = temp_y + size_tile_y + tile_offset_y +1;   
  CAM.center_screen_on_player();
  return true;
}


//*******************************************************************************
//* save_map
//*
//*******************************************************************************
static bool TENG::save_map (String filename, int _tileset_sprite, bool use_savegamedir)
{
  int i, j, k, index;
  int waypoint_count;
  int platform_count;
  int item_count;
  int people_count;
  int hotspot_count;
  int new_current_tile;
  
  int fg_tile_cnt;
  int bg_tile_cnt;
  
  i = 0;
  j = 0;
  k = 0;
  String levelname;
  if (use_savegamedir) levelname = "$SAVEGAMEDIR$/";
  else levelname=path;
  
  levelname = levelname.Append(filename);
  levelname = levelname.Append(".lvl");

  if (_tileset_sprite >0) tileset_sprite = _tileset_sprite;
  
  TILES.init_tile_sprites(tileset_sprite);

	File *file = File.Open(levelname, eFileWrite);
	if (file == null)	return false;

  // Save Map Header
  file.WriteInt(session_id);
  file.WriteInt(tileset_sprite);
  file.WriteInt(num_different_tiles);
	file.WriteInt(size_tile_x);
	file.WriteInt(size_tile_y);
  
  file.WriteInt(num_tiles_x);
  file.WriteInt(num_tiles_y);

  // Save Player Spawn;
  file.WriteInt(ego_stats.startx);
  file.WriteInt(ego_stats.starty);
  
  // Save TileCodes  
  i =0;
  while (i <num_different_tiles) {
    file.WriteInt(tile_sprites[i].code);
    i++;
  }
  
  // Save Tiles
  i=0;
  j=0;
  k=0;
  index = 0;
  

  //Count Tiles
  while ( k < LAYERS ) {
    j = 0;
    index = 0;
    while ( j < num_tiles_y ) {
      i = 0;
      while ( i < num_tiles_x ) {
        if (tile[index].tileno[k]>0) {
          if (k==0) bg_tile_cnt++;
          else if (k==1) fg_tile_cnt++;
        }
        index ++;
        i++;
      } 
      j++;
    }
    k++;
  }
 
  //Save BG Tiles
  j=0; 
  index = 0;
  file.WriteInt(bg_tile_cnt);
  while ( j < num_tiles_y ) {
    i = 0;
    while ( i < num_tiles_x ) {
      if (tile[index].tileno[0]>0) {
        file.WriteInt(index);
        file.WriteInt(tile[index].mirrored_x[0]);
        file.WriteInt(tile[index].mirrored_y[0]);
        file.WriteInt(tile[index].tileno[0]);
      }
      index ++;
      i++;
    } 
    j++;
  }  
  
  //Save FG Tiles
  j=0;
  index = 0;
  file.WriteInt(fg_tile_cnt);
  while ( j < num_tiles_y ) {
    i = 0;
    while ( i < num_tiles_x ) {
      if (tile[index].tileno[1]>0) {
        file.WriteInt(index);
        file.WriteInt(tile[index].mirrored_x[1]);
        file.WriteInt(tile[index].mirrored_y[1]);
        file.WriteInt(tile[index].tileno[1]);
      }
      index ++;
      i++;
    } 
    j++;
  } 
 
  index =0;
  i=0;
  j=0;
  k=1;
  
  // Save Waypoints
  while (i<MAX_WAYPOINTS) {
    if (waypoint[i].active) waypoint_count++;
    i++;
  } 
  file.WriteInt(waypoint_count);
  i=0;
  while (i<MAX_WAYPOINTS) {
    if (waypoint[i].active)  {
      file.WriteInt(waypoint[i].x);
      file.WriteInt(waypoint[i].y);
      file.WriteInt(waypoint[i].nextDir);
    }
    i++;
  }
  
  i =0;
  
  // Save Platforms
  while (i < MAX_PLATFORMS) {
    if (platform[i].sprite != 0) platform_count++;
    i++;
  }
  file.WriteInt(platform_count);
  i =0;
  while (i<MAX_PLATFORMS) {
    if (platform[i].sprite != 0)  {
      new_current_tile = TILES.get_tile_at(platform[i].x +1,platform[i].y +1);
      file.WriteInt(new_current_tile);
      file.WriteInt(platform[i].xspeed);
    }
    i++;
  }
  i=0;
  
  // Save Items
  while (i < MAX_ITEMS) {
    if (item[i].active) item_count++;
    i++;
  }
  file.WriteInt(item_count);
  i=0;
  
  while (i < MAX_ITEMS) {
    if (item[i].active) {
      if (!item[i].ignore_gravity || item[i].xspeed!=0 || item[i].yspeed !=0) new_current_tile = TILES.get_tile_at(item[i].x +1,item[i].y +1);
      else new_current_tile = item[i].current_tile;
      file.WriteInt (new_current_tile);
      file.WriteInt (item[i].type);
      file.WriteInt (item[i].loop);
      file.WriteInt (item[i].obj_id);
      
      if (item[i].vf != null && item[i].vf.Graphic !=0) file.WriteInt (item[i].vf.Graphic);
      else file.WriteInt (item[i].obj_sprite);
      file.WriteInt (item[i].img);
      file.WriteInt (item[i].hidden);
      file.WriteInt (item[i].is_solid);
      file.WriteInt (item[i].usable);
      file.WriteInt (item[i].ignore_gravity);
      file.WriteInt (item[i].in_foreground);
      if (item[i].name != null) file.WriteString (item[i].name);
      else file.WriteString("");
      if (item[i].shown_name != null) file.WriteString (item[i].shown_name);
      else file.WriteString("");
      

    }
    i++;
  }
  
  i=0;
  
  // Save People
  while (i<MAX_PEOPLE) {
    if (people[i].active) people_count++;
    i++;
  }
  file.WriteInt(people_count);
  
  i=0;
  while (i<MAX_PEOPLE) {
    if (people[i].active) {
      new_current_tile = TILES.get_tile_at(people[i].x, people[i].y -4);
      file.WriteInt   (people[i].type); 
      file.WriteInt   (people[i].id);
      file.WriteInt   (new_current_tile);
      file.WriteInt   (people[i].view);
      file.WriteInt   (people[i].talk_view);
      file.WriteInt   (people[i].talk_color);
      file.WriteInt   (people[i].idle_view);
      file.WriteInt   (people[i].is_interactable);
      file.WriteInt   (people[i].is_hostile);
      file.WriteInt   (people[index].limit_left);
      file.WriteInt   (people[index].limit_right);
      file.WriteInt   (people[index].limit_up);
      file.WriteInt   (people[index].limit_down);  
      if (people[i].name != null) file.WriteString (people[i].name);
      else file.WriteString("");
    }
    i++;
  }  
  i = 0;
  
  // Save Hotspots
  while (i<MAX_HOTSPOTS) {
    if (t_hotspot[i].active) hotspot_count++;
    i++;
  }
  file.WriteInt(hotspot_count);
  i = 0;
  
  while (i<MAX_HOTSPOTS) {
    if (t_hotspot[i].active) {
      file.WriteInt(t_hotspot[i].x);
      file.WriteInt(t_hotspot[i].y);
      file.WriteInt(t_hotspot[i].id);
      file.WriteInt(t_hotspot[i].hidden);
      file.WriteInt(t_hotspot[i].img);
      if (t_hotspot[i].name != null) file.WriteString (t_hotspot[i].name);
      else file.WriteString("");
      if (t_hotspot[i].shown_name != null) file.WriteString (t_hotspot[i].shown_name);
      else file.WriteString("");         
    }
    i++;
  }  
  file.Close();
  return true;
}


//*******************************************************************************
//* update_map_classic
//*
//*******************************************************************************
static bool TENG::update_map_classic(String filename)
{
  File* f;
  int k = 0;
  int i = 0;
  int j = 0;
  int info = 0;
  String s = "";
  String fs;
  int code =0;
  int _attrib =0;  
  
  int index =0;
  
  if (size_tile_x == 0 || size_tile_y == 0) {
    Display ("You need to load a level first.");
    return false;
  }
  fs = String.Format("%s%s#map00%d.map", path, filename, k);
  f = File.Open(fs, eFileRead);
  if (f == null) {
    Display ("Can't load file.");
    return false;
  }
  TILES.clear_all_tiles(true);
  // Getting Dimensions from Level File
  num_tiles_x = f.ReadRawInt();
  num_tiles_y = f.ReadRawInt();
  
  mapwidth = num_tiles_x * size_tile_x;
  mapheight =  num_tiles_y * size_tile_y;
      
  
  // loop through lines
  while ( j < num_tiles_y )
  {
    i = 0;
    
    while ( i < num_tiles_x )
    {    
      TILES.clear_tile(index, k);
      
      tile[index].x[k] = i * size_tile_x;
      tile[index].y[k] = j * size_tile_y;
      
      info = f.Readword();
      tile[index].tileno[k] = info & 1023;
      if (tile[index].tileno[k] != 0) {
        if ((info & 1024) != 0) tile[index].mirrored_x[k] = true;
        if ((info & 2048) != 0) tile[index].mirrored_y[k] = true; 
        if (tile_sprites[ tile[index].tileno[k] ].spr != null) {
          tile[index].spr[k] = DynamicSprite.CreateFromExistingSprite(tile_sprites[ tile[index].tileno[k] ].spr.Graphic, true);
          if (tile[index].mirrored_x[k] && tile[index].mirrored_y[k]) tile[index].spr[k].Flip(eFlipBoth);
          else if (tile[index].mirrored_x[k]) tile[index].spr[k].Flip(eFlipLeftToRight);
          else if (tile[index].mirrored_y[k]) tile[index].spr[k].Flip(eFlipUpsideDown);
        }
        
        code = tile_sprites[ tile[index].tileno[k] ].code;
        TILES.define_tiles(index, k, code);
      }
      index ++;
      i++;
    }
    
    j++;
  }    
  f.Close();  
  f = null;
  fs = ""; 
  return true;
}

//*******************************************************************************
//* load_map_files
//*
//* PARAMETERS:
//*   String filename 
//*   int _size_tile_x
//*   int _size_tile_y
//*   int _tile_scrolling_edge_h: x-pos at which the screen starts scrolling
//*   int _tile_scrolling_edge_v: y-pos where the screen starts scrolling
//*   int _tile_offset_x: offset to the screen borders
//*   int _tile_offset_y: offset to the screen borders
//*
//*******************************************************************************
static bool TENG::load_map_classic ( String filename, int _size_tile_x, int _size_tile_y, int _tile_scrolling_edge_h, int _tile_scrolling_edge_v, int tile_sprite, bool strict)
{
  String fs, fs_tlc, fs_test_tlc;
  File* f, f_tlc,  f_test_tlc;
	size_tile_x = _size_tile_x;
	size_tile_y = _size_tile_y;
	tile_scrolling_edge_h = _tile_scrolling_edge_h;
	tile_scrolling_edge_v = _tile_scrolling_edge_v;
	tile_offset_x = 0;
	tile_offset_y = 0;
	  
  tile_limit_x = (tile_scrolling_edge_h / size_tile_x);
  tile_limit_y = (tile_scrolling_edge_v / size_tile_y);

  int i = 0;
  int j = 0;
  int k = 0;
  
  int max_tile_spr_x = 0;
  int max_tile_spr_y = 0;
  
  int info;
  String s;
  int code;
  int _attrib;  
  int _loop;
  int _flag;  
  int temp_tile;
  int temp_x;
  int temp_y; 
  int index;
    
  DynamicSprite *tile_strip;
  
  if (tile_sprite >0) {
    tile_strip = DynamicSprite.CreateFromExistingSprite(tileset_sprite);    
  }
  else {
    // open tile strip file
    fs = String.Format("%s%s#tiles.pcx", path, filename);  
    if (!File.Exists(fs)) fs = String.Format("%s%s#tiles.bmp", path, filename);
    if (!File.Exists(fs)) return false;
    tile_strip = DynamicSprite.CreateFromFile(fs);
    if (tile_strip == null) return false;
  }
  // Get tile code file
  fs_tlc = String.Format("%s%s.tlc", path, filename);

  if (!File.Exists(fs_tlc)) return false;

  f_tlc = File.Open(fs_tlc, eFileRead);
  if (f_tlc == null) return false;
  
  DrawingSurface *strip_surf = tile_strip.GetDrawingSurface();
  // populate dyn sprite file
  
  max_tile_spr_x = tile_strip.Width / size_tile_x;
  max_tile_spr_y = tile_strip.Height / size_tile_y;
  
  TileRaster = DynamicSprite.CreateFromExistingSprite(376);
  TileRaster.Crop(0, 0, size_tile_x, size_tile_y);
  
  i = 0;
  j = 0;
  while (j < max_tile_spr_y) {
    while (i < max_tile_spr_x) {
      if ((j * max_tile_spr_x + i) < NUM_MAX_SPRITES) {
        tile_sprites[j * max_tile_spr_x + i].spr = DynamicSprite.CreateFromDrawingSurface(strip_surf, i * size_tile_x, j*size_tile_y, size_tile_x, size_tile_y);
        tile_sprites[j * max_tile_spr_x + i].code = f_tlc.Readword();
      }
      i++;
    }
    j++;
  }
  strip_surf.Release();
  f_tlc.Close();
  tile_strip.Delete();
  tile_strip = null;
  
  // Reading map: tile info
  while ( k < LAYERS )
  {
    fs = String.Format("%s%s#map00%d.map", path, filename, k);
    if (!File.Exists(fs) && k == 0) return false;
    else if (!File.Exists(fs) && k == 1 && strict) return false;
    else if (File.Exists(fs) && (k == 0 || k == 1))
    {
      f = File.Open(fs, eFileRead);
      if (f == null) return false;
      
      // Getting Dimensions from Level File
      if (k==0) {
        num_tiles_x = f.ReadRawInt();
        num_tiles_y = f.ReadRawInt();
        
        mapwidth = num_tiles_x * size_tile_x;
        mapheight =  num_tiles_y * size_tile_y;
      } else {


        f.ReadRawInt();
        f.ReadRawInt();
      }
          
      i = 0;
      j = 0;
      info = 0;
      s = "";
      code =0;
      _attrib =0;  
      
      index =0;
      
      // loop through lines
      while ( j < num_tiles_y )
      {
        i = 0;
        
        while ( i < num_tiles_x )
        {    
          TILES.clear_tile(index, k);
          
          tile[index].x[k] = i * size_tile_x;
          tile[index].y[k] = j * size_tile_y;
          
          info = f.Readword();
          tile[index].tileno[k] = info & 1023;
          if (tile[index].tileno[k] != 0) 
          {
            if ((info & 1024) != 0) tile[index].mirrored_x[k] = true;
            if ((info & 2048) != 0) tile[index].mirrored_y[k] = true; 
            
            tile[index].spr[k] = DynamicSprite.CreateFromExistingSprite(tile_sprites[ tile[index].tileno[k] ].spr.Graphic, true);
            
            if (tile[index].mirrored_x[k] && tile[index].mirrored_y[k]) tile[index].spr[k].Flip(eFlipBoth);
            else if (tile[index].mirrored_x[k]) tile[index].spr[k].Flip(eFlipLeftToRight);
            else if (tile[index].mirrored_y[k]) tile[index].spr[k].Flip(eFlipUpsideDown);
            
            code = tile_sprites[ tile[index].tileno[k] ].code;
            TILES.define_tiles(index, k, code);
          }
          index ++;
          i++;
        }
        
        j++;
      }    
      f.Close();  
      f = null;
      fs = "";
      
    }
    k++;
  }  
  
  // Read Items, moving platforms and Waypoints from Map Layer 3
  fs = String.Format("%s%s#map003.map", path, filename);
  if (File.Exists(fs)) {

    f = File.Open(fs, eFileRead);
    if (f == null) return false;  

    f.ReadRawInt();
    f.ReadRawInt();

    i = 0;
    j = 0;
    info = 0;
    s = "";
    code =0;
    _attrib =0; 
    temp_tile = 0;
    temp_x = 0;
    temp_y = 0;
    
    index = 0;
    
    // loop through lines
    while ( j < num_tiles_y )
    {
      i = 0;
      
      while ( i < num_tiles_x )
      {
        info = f.Readword();
        temp_tile = info & 1023;      
        
        if (temp_tile != 0)  {
          
          temp_x = i * size_tile_x;
          temp_y = j * size_tile_y;
          
          code = tile_sprites[ temp_tile ].code;
          
          _attrib  = TILES.split_tilecode(eCodepartAttrib, code);
          _loop = TILES.split_tilecode(eCodepartLoop, code);
          _flag = TILES.split_tilecode(eCodepartFlag, code);
          
          // Waypoints
          if (_attrib == 1 ) {
            // set up a waypoint
            waypoint[wp_index].x = temp_x;
            waypoint[wp_index].y = temp_y;
            waypoint[wp_index].active = true;
            wp_index++;
          }
          // Platform horizontal
          else if (_attrib == 2) {
            PFORM.clear_platform(pf_index);
            platform[pf_index].x = temp_x + size_tile_x + tile_offset_x;
            platform[pf_index].y = temp_y + tile_offset_y;
            platform[pf_index].sprite        = tile_set.platform_hori;  
            platform[pf_index].facing          = -1; 
            platform[pf_index].xspeed          = 2;
            platform[pf_index].speed_delay     = 0;
            platform[pf_index].wait_timer      = 100;
            platform[pf_index].current_tile    = index;

            pf_index ++;           
          }
          // Platform vertical
          else if (_attrib == 3) {       
            PFORM.clear_platform(pf_index);
            platform[pf_index].x = temp_x + tile_offset_x;
            platform[pf_index].y = temp_y + tile_offset_y;
            platform[pf_index].sprite        = tile_set.platform_vert;  
            platform[pf_index].facing          = -1; 
            platform[pf_index].yspeed          = 1;
            platform[pf_index].wait_timer      = 100;
            platform[pf_index].current_tile    = index;
            pf_index ++;          
          }
          // Items
          else if (_attrib > 10) {
            ITM.clear_item(itm_index);
            item[itm_index].current_tile = index;
            ITM.define_items(itm_index, temp_x + tile_offset_x, temp_y + tile_offset_y, _loop,_flag, _attrib);
            itm_index++;
          }
        }
        index ++;
        i++;
      }
      
      j++;
    }    
    f.Close();  
    f = null;
    fs = "";
  }
  else if (!File.Exists(fs) && strict) return false;
  
  // Read Player and People's position from Map Layer 4 
  fs = String.Format("%s%s#map004.map", path, filename);
  if (File.Exists(fs)) {

    f = File.Open(fs, eFileRead);
    if (f == null) return false;  
    
    f.ReadRawInt();
    f.ReadRawInt();

    i = 0;
    j = 0;
    info = 0;
    s = "";
    code =0;
    _attrib =0; 
    _flag = 0;
    _loop = 0;
    temp_tile = 0;
    temp_x = 0;
    temp_y = 0;
    index =0;
    // loop through lines
    while ( j < num_tiles_y )
    {
      i = 0;
      
      while ( i < num_tiles_x )
      {
        info = f.Readword();
        temp_tile = info & 1023;       
        
        if (temp_tile != 0)  {
          
          temp_x = i * size_tile_x;
          temp_y = j * size_tile_y;
          
          code = tile_sprites[ temp_tile ].code;
          
          _attrib = TILES.split_tilecode(eCodepartAttrib, code);
          _flag   = TILES.split_tilecode(eCodepartFlag, code);
          
          //Player

          if (_attrib == 1 && _flag == 0) {
            player.x = temp_x + ( size_tile_x / 2 ) + tile_offset_x;
            player.y = temp_y + size_tile_y + tile_offset_y +1;
            ego_stats.startx = i;
            ego_stats.starty = j;
            ego_stats.current_tile = index;
            
          }
          else {
            PEOPLE.clear_people(people_index);     
            PEOPLE.define_people(people_index, index, temp_x + ( size_tile_x / 2 )  + tile_offset_x, temp_y + size_tile_y + tile_offset_y+1, _flag, _attrib);
            people_index++;  
          }
            
        }
        index++;
        i++;
      }
      
      j++;
    }    
    f.Close();  
    f = null;
    fs = "";
  }
  else if (!File.Exists(fs) && strict) return false;
  
  // Read Hotspots from Map Layer 5
   
  fs = String.Format("%s%s#map005.map", path, filename);
  if (File.Exists(fs)) {
    
    t_hotspot_index = 0; 
    
    f = File.Open(fs, eFileRead);
    if (f == null) return false;  
    
    f.ReadRawInt();
    f.ReadRawInt();

    i = 0;
    j = 0;
    info = 0;
    s = "";
    code =0;
    _attrib =0; 
    temp_tile = 0;
    temp_x = 0;
    temp_y = 0;
    index =0;

    // loop through lines
    while ( j < num_tiles_y )
    {
      i = 0;
      
      while ( i < num_tiles_x )
      {
        info = f.Readword();
        temp_tile = info & 1023;       
        
        if (temp_tile != 0)  {
                   
          code = tile_sprites[ temp_tile ].code;
          
          _attrib  = TILES.split_tilecode(eCodepartAttrib, code);
          
          //Hotspot 1
          if (_attrib > 0 ) {
            HSP.clear_t_hotspot(t_hotspot_index);
            t_hotspot[t_hotspot_index].x  = i;
            t_hotspot[t_hotspot_index].y  = j;
            t_hotspot[t_hotspot_index].id = _attrib;
            t_hotspot[t_hotspot_index].active = true;
            t_hotspot_id[t_hotspot[t_hotspot_index].id] = t_hotspot_index;
            t_hotspot_index++;
          }        
        }
        index++;
        i++;
      }
      
      j++;
    }    
    f.Close();  
    f = null;
    fs = "";
  }
  else if (!File.Exists(fs) && strict) return false;
  CAM.center_screen_on_player();
  
  return true;
}


//*******************************************************************************
//* updateStatusGui
//* Shows score, active weapon and so on
//*
//*******************************************************************************
static function TENG::updateStatusGui()
{
  //int length = FloatToInt ( (IntToFloat (ego_stats.health)/100.0) * IntToFloat(Game.SpriteWidth[btnStatHealth.Graphic]-4) );  
  
  int bar_maxwidth= ego_stats.max_health;//Game.SpriteWidth[btnStatHealth.Graphic];
  int bar_width = FloatToInt((IntToFloat(ego_stats.health) / IntToFloat(ego_stats.max_health)) * IntToFloat(bar_maxwidth), eRoundNearest);
  
  int next_exp = RPGLevel.get_next_exp();
  int current_exp_threshold = RPGLevel.get_current_exp();
  
  int exp_width = FloatToInt((IntToFloat( ego_stats.exp - current_exp_threshold) / IntToFloat(next_exp-current_exp_threshold)) * 20.0, eRoundNearest);
  
  lblStatHealth.Text = String.Format("%d/%d",ego_stats.health, ego_stats.max_health);
  lblStatHealth2.Text = lblStatHealth.Text;
  lblStatArc.Text = String.Format("%d",ego_stats.arcanium);
  lblStatArc2.Text = lblStatArc.Text;
  
  if (ego_stats.active_weapon != eWNoWeapon && ego_stats.active_weapon != eWCloseCombat ) {
    //lblStatArms.Visible = true;
    lblStatAmmo.Visible = true;
    lblStatAmmo.Text = String.Format("%d",weapon[ego_stats.active_weapon].ammo);
  }
  else {
    //lblStatArms.Visible = false;
    lblStatAmmo.Visible = false;    
  }
  btnStatBar.Width = bar_width;
  btnStatHealth.Width = ego_stats.max_health;
  btnStatHealthEnd.X = btnStatHealth.Width + btnStatHealth.X;
  btnExpBar.Width = exp_width;

  if (ego_stats.old_active_inv == null && ego_stats.active_inv  != null) {
      ego_stats.old_active_inv = ego_stats.active_inv;
      btnStatActiveItm.NormalGraphic = ego_stats.active_inv.Graphic;    
  }
  else if (ego_stats.old_active_inv != null && ego_stats.active_inv != null) {
    if (ego_stats.old_active_inv != ego_stats.active_inv) {
      ego_stats.old_active_inv = ego_stats.active_inv;
      btnStatActiveItm.NormalGraphic = ego_stats.active_inv.Graphic;
    }
  }  
}

static int TENG::get_tile_strip_slot()
{
  return tileset_sprite;
}
static void TENG::set_tile_strip_slot(int slot)
{
  if (slot>0) tileset_sprite = slot;
}

//*******************************************************************************
//* init_game
//*
//*******************************************************************************
static function TENG::init_game() 
{
  wp_index = 0;
  pf_index = 0;

  lblStatAmmo.Visible = false;  
  Settings.load();
  WPN.init_weapons();
  CTRL.init_controls();
  EGO.init_player ();
  ITM.init_item_types();
  PEOPLE.init_people_types();
  RPGLevel.init_levels();
  Speech.SkipKey = eKeyEscape;
  
  path = "tilemaps/";
  cPlayer.Baseline=200;
  Foreground = DynamicSprite.Create(Screen.Width, Screen.Height, true);
  gForeground.BackgroundGraphic = Foreground.Graphic;
  Mouse.Visible = false;
  Mouse.Mode = eModePointer;
  ego_stats.lifes = 5;
  ego_stats.arcanium  = 0;
  ego_stats.exp       = 0;
  ego_stats.health    = 20;
  ego_stats.max_health    = ego_stats.health;
  ego_stats.rpg_level     = 0;
  ego_stats.was_midair    = false;

  SetGameSpeed(60);
}


//*******************************************************************************
//* check_for_saved_room
//* Checks if there's a savestate for given room
//*
//*******************************************************************************
static bool TENG::check_for_saved_room (int room_number)
{
  int temp_session;
  
  String filename = String.Format("$SAVEGAMEDIR$/state_%d.lvl",room_number);
  
  if (File.Exists(filename))  {
    File *file = File.Open(filename, eFileRead);
    if (file == null)	return false;
    
    temp_session = file.ReadInt();    
    file.Close();
    
    if (temp_session == session_id) return true;
    else {
      File.Delete(filename);
      return false;
    }
  }
}

//*******************************************************************************
//* change_room
//* Saves the room first and then changes it
//*
//*******************************************************************************
static function TENG::change_room(int number)
{
  TRANS.circle_fadeout(player.x, player.y - (INFO.get_char_height(player)/2));
  gLoading.Visible=true;
  mouse.Visible=false;
  int spawn_tile = TILES.get_tile_at(player.x, player.y - ego_stats.footwidth);
  EGO.set_spawn(spawn_tile);
  Wait(1);
  while (!TENG.save_map(String.Format("state_%d",player.Room))) Wait(1);
  TENG.stop();
  TENG.set_topdown_mode(false);
  
  while (!TENG.clean_up())Wait(1);

  player.ChangeRoom(number);
}

//*******************************************************************************
//* remove_saved_room
//*
//*******************************************************************************
static function TENG::remove_saved_room(int room_number)
{
  String filename = String.Format("$SAVEGAMEDIR$/state_%d.lvl",room_number);
  if (File.Exists(filename))  File.Delete (filename);
}

//*******************************************************************************
//* handle_player_death
//* Checks if the player is dead, handles the dying animation, 
//* ends the game if needed
//*
//*******************************************************************************
static function TENG::handle_player_death()
{
  // check for deadly Tile
  if (ego_stats.DeadlyTile && !ego_stats.is_dead && !ego_stats.is_dying) {
    ego_stats.health = 0;
    ego_stats.NoControl = true;   
  }
  
  if (ego_stats.is_dead && ego_stats.DeadlyTile) {
    ego_stats.DeadlyTile = false;
    ego_stats.health = 0;
  }
  
  if (ego_stats.is_dead) {
    
    if (ego_stats.lifes == 0) {
      Display ("ARGH! Game Over");
      gLoading.Visible=true;
      TENG.stop();
      if (TENG.clean_up()) player.ChangeRoom(1);    
    }
    else if (ego_stats.lifes > 0) {
      player.Loop = ego_stats.direction;
      ego_stats.is_dead = false;
      ego_stats.NoControl = false;
      ego_stats.health = ego_stats.max_health;
      ego_stats.lifes --;
      int start_tile = TILES.getTileIndexFromTileIndices(ego_stats.startx,ego_stats.starty);
      CAM.beam_to_place(player, 0, start_tile, true);
      EGO.set_player_invincible(160);

    }
  }
  
  if (ego_stats.health <= 0 && !ego_stats.is_dying) {
    player.Frame = 0;
    ego_stats.NoControl = true;
    ego_stats.xspeed = 0;
    ego_stats.xaccel = 0;
    ego_stats.yaccel = 0;
    ego_stats.yspeed = 0;    
    ego_stats.anicounter = 0;
    ego_stats.invincible_timer = 0;
    ego_stats.invincible_cnt = 0;
    ego_stats.s_invincible = false;
    if (player.HasExplicitTint) player.RemoveTint();
    ego_stats.is_dying = true;

  }

  
  if (ego_stats.is_dying) {
    if (player.View != VPLAY_STD) {
      player.ChangeView(VPLAY_STD);
      player.Frame = 0;
    }

    if (ego_stats.direction == eTengDirLeft) player.Loop = 16;
    else player.Loop = 17;

    ViewFrame *CurrentFrame = Game.GetViewFrame(player.View, player.Loop, player.Frame);
    int framecount = Game.GetFrameCountForLoop(player.View, player.Loop);

    if (ego_stats.anicounter >= player.AnimationSpeed + CurrentFrame.Speed) {
      if (player.Frame == framecount-1) {
        ego_stats.is_dead  = true;
        ego_stats.is_dying = false;
      }
      else player.Frame ++;
      ego_stats.anicounter = 0;
    }
    else ego_stats.anicounter ++;
  }

}


//*******************************************************************************
//* toogle_pause
//*******************************************************************************

function toogle_pause()
{
  // Pause
  if (TENG_running) {
    if (pause_lock && !CTRL.isControlPause()) pause_lock = false;

    if (!gSpeech.Visible && !IsGamePaused() && !pause_lock && CTRL.isControlPause()) {
      pause_lock = true;
      show_menu(true);
      //PauseGame();
    }
    else if (IsGamePaused() && !pause_lock && CTRL.isControlPause()) {
      pause_lock = true;
      //UnPauseGame();    
    }
  }  
}

//*******************************************************************************
//* handle_blocking
//*******************************************************************************
function handle_blocking()
{
  if ( total_f(ego_stats.x_speed) >= MAX_XSPEED ) ego_stats.GrabPossible = false;
  // release locks
  if (!CTRL.isControlDown() && ego_stats.InSlide == 0) ego_stats.Slide_Pressed = false;   
  
  if (!CTRL.isControlInteract()) use_lock = false;

  if (walkOn_lock && ego_stats.current_action != eTAct_WalkOnHotspot && ego_stats.current_action != eTAct_WalkOnObject ) {
    walkOn_lock = false;
  }

  // release jump
  if(!CTRL.isControlJump() || ego_stats.NoControl) {
    ego_stats.Jump_Pressed = false;
    ego_stats.Jump_Timer = -1;
  }
  else if (ego_stats.Jump_Timer > -1) {
    ego_stats.Jump_Timer ++;
  }
  if (!CTRL.isControlUp() && !CTRL.isControlDown()) ego_stats.y_accel=0.0;
  
  if (ego_stats.Jump_Timer >=JUMP_HEIGHT -1) ego_stats.GrabPossible = true;

  // release ducking
  if (!CTRL.isControlDown() && ego_stats.Ducks) ego_stats.Ducks =false;    
  
  if (!ego_stats.NoControl && !ego_stats.beam && !ego_stats.is_invisible && !in_speech) {
    if (topdown_mode) CTRL.handle_controls_topdown();
    else CTRL.handle_controls();
  }
  
  if (!ego_stats.beam && !ego_stats.que_up_ani && !ego_stats.is_dying && !ego_stats.is_dead && !ego_stats.is_invisible && !in_speech) {
    if (topdown_mode) EGO.move_player_topdown();
    else EGO.move_player();
  }
  if (!ego_stats.is_dying && !ego_stats.is_dead && !ego_stats.is_invisible ) {
    if (topdown_mode) EGO.animate_player_topdown();
    else EGO.animate_player();
  }  
  if(ego_stats.ShotTimer <= SHOT_INTERVAL ) ego_stats.ShotTimer ++;   
  frame_drop = !frame_drop;
  if (refresh_timer_called && !frame_drop) refresh_timer ++;  
  TENG.handle_player_death();
}


//*******************************************************************************
//* handle_nonblock
//*******************************************************************************
function handle_nonblocking()
{
  toogle_pause();
  ego_stats.Jumped = false;
  ego_stats.Found_Floor = false;
  
  if (!skippy_frames  || (skippy_frames && !frame_drop)) {
    DrawingSurface *mainBackground = Room.GetDrawingSurfaceForBackground();
    mainBackground.Clear(COLOR_TRANSPARENT);
    mainBackground.Release();
  }
  CAM.handle_scrolling();
  
  PARALLAX.handle_parallax();
  if (!skippy_frames || (skippy_frames && !frame_drop ))PARALLAX.draw_parallax(false);
  

  if (frame_drop)TILES.handle_anisync_tiles();
  if (!skippy_frames  || (skippy_frames && !frame_drop)) {
    TILES.draw_tiles();  
    Particle.render(cam_scroll_x, cam_scroll_y);
  }
  BULLET.draw_bullets();
  
  ITM.handle_items(); //framedrop's inside this function
  
  BULLET.handle_player_bullets();
  
  if (!ego_stats.is_dying && !ego_stats.is_dead &&!ego_stats.is_invisible) BULLET.handle_enemy_bullets();

  EGO.handle_player_invincibility();
  
  PFORM.handle_platforms();//framedrop's inside this function

  if (!ego_stats.is_dying && !ego_stats.is_dead && !ego_stats.is_invisible && !in_speech) COLL.check_player_coll();    
  if (!ego_stats.is_dying && !ego_stats.is_dead && !ego_stats.is_invisible && !in_speech && IsInterfaceEnabled()) MARKER.draw_marker();
  if (!ego_stats.is_dying && !ego_stats.is_dead && !ego_stats.is_invisible && !in_speech) PEOPLE.handle_people();
  if (!skippy_frames || (skippy_frames && !frame_drop ))PARALLAX.draw_parallax(true);
  if (frame_drop) {
    TENG.updateStatusGui();
    Particle.update();
  }
}

//*******************************************************************************
//* AGS repeatedly_execute
//*******************************************************************************
function repeatedly_execute( )  
{
  if (!IsGamePaused()) {
    if (TENG_running)handle_blocking();
    if (!CTRL.isControlInv()) inv_lock = false;
  }
  
}

//*******************************************************************************
//* AGS repeatedly_execute_always
//*******************************************************************************
function repeatedly_execute_always( ) 
{
  if (TENG_running && !IsGamePaused()) handle_nonblocking();
  if (game_cycle <40) game_cycle++;
  else game_cycle = 0;
}


//*******************************************************************************
//* AGS on_mouse_click
//*******************************************************************************
function on_mouse_click (MouseButton button) {
  if (!IsGamePaused() && TENG_running) {
    // shoot per mouseclick
    if (button == eMouseRight) {
      ClaimEvent();
    }
  }
}


//*******************************************************************************
//* AGS game_start
//*******************************************************************************
function game_start() 
{
  TENG.init_game();
  session_id = Random(998) + 1;
  session_id+= Random(999);
  session_id+= Random(999);
}


//*******************************************************************************
//* AGS on_key_press
//*******************************************************************************
function on_key_press (eKeyCode keycode) {
  /*
  if (TENG_running && keycode == eKeyF1) {
    KeySwap.Refresh();
    gPlayerStats.Visible = false;
    Mouse.Visible = true;
    gKSKeyMap.Visible = true;
  }
  else if (TENG_running && keycode == eKeyF2) {
    MapJoy.Refresh();
    gPlayerStats.Visible = false;
    Mouse.Visible = true;
    gJoyMap.Visible = true;
  }  
  */
}