// room script file
//TODO:
// Sorting function for Waypoints, Items etc?
//
DynamicSprite *sceneBuffer;
DynamicSprite *editorBuffer;

import String tileTypes[TILE_TYPES];

enum ToolMode
{
	ToolMode_Tile, 
	ToolMode_Item, 
	ToolMode_Object,
	ToolMode_Enemy,
  ToolMode_People, 
	ToolMode_Hotspot, 
  ToolMode_Settings
};

ToolMode toolMode;
int toolStage;
int toolBufferX, toolBufferY;
int toolDirection = 1;

bool show_tiles, show_items, show_objects, show_people, show_hotspots;

bool drawGrid = true;
bool isLeftMouseButtonDown, isRightMouseButtonDown, isLeftArrowKeyDown, isRightArrowKeyDown, isTabKeyDown;
bool isSpaceDown, isNewKeyDown, isLoadKeyDown, isSaveKeyDown, isResizeKeyDown, isGridKeyDown, isTileFlipXKeyDown, isTileFlipYKeyDown;
bool isDropperKeyDown;
bool levelLoaded;
bool show_map = false;
bool scrollUpActive, scrollDownActive;
int current_tile =0;
bool mirror_tile_x,  mirror_tile_y;


int scroll_from =1, scroll_to=1;
int rows_needed, tilesPerRow, tilesPerCol;
int selected_tile =0;
int selected_object =0;
int selected_enemy = -1;
int selected_npc = -1;
int selected_hotspot = 0;

eItem_type selected_item = itm_nothing;
int layer = 0;
bool item_hidden;
import int tileset_sprite;
import bool frame_drop;
import DynamicSprite *Foreground;
import ctile_set tile_set;
import ctile_sprites tile_sprites[NUM_MAX_SPRITES];
import citem_types item_types[MAX_ITEMS];

import short t_object_id[MAX_ITEMS];
import citems item[MAX_ITEMS];

import short people_id[MAX_PEOPLE];
import cpeople people[MAX_PEOPLE];
import cpeople_types people_types[MAX_PEOPLE];

import short t_hotspot_id[MAX_HOTSPOTS];
import ct_hotspot t_hotspot[MAX_HOTSPOTS];
import int size_tile_x;
import int size_tile_y;

struct cBrush {
  int tile;
  int code;
  DynamicSprite *spr;
  bool mirror_x, mirror_y;
  
};

int brush_max_idx;
int brush_dimx;
int brush_dimy;

cBrush brush[256];

//*******************************************************************************
//* drawMarker
//*
//*******************************************************************************
void drawMarker(DrawingSurface *surface, int x, int y, int color, String text)
{
	surface.DrawingColor = color;
	surface.DrawLine(x - 2, y - 2, x + 2, y + 2);
	surface.DrawLine(x - 2, y + 2, x + 2, y - 2);
	surface.DrawString(x + 6, y - 6, eFontFont3, text);
}


//*******************************************************************************
//* drawButton
//*
//*******************************************************************************
void drawButton(DrawingSurface *surface, int x, int y, int width, int height, int color, int border_color,  bool activated, String text, int spriteslot)
{
	if (activated)
	{
		surface.DrawingColor = 15;
		surface.DrawRectangle(x -1, y-1 , x + width +1, y + height +1);
    
		surface.DrawingColor = border_color;
		surface.DrawRectangle(x, y, x + width , y + height );     
		surface.DrawingColor = color;
		surface.DrawRectangle(x+1, y+1, x + width-1, y + height-1);     
	}
	else
	{
		surface.DrawingColor =  border_color;
		surface.DrawRectangle(x, y, x + width, y + height);    
		surface.DrawingColor = color;
		surface.DrawRectangle(x+1, y+1, x + width-1, y + height-1);
	}
	if (spriteslot != 0) surface.DrawImage(x+1, y+1, spriteslot, 0, size_tile_x, size_tile_y);
	surface.DrawingColor = 15;
  surface.DrawStringWrapped(x+1, y+1, width, eFontTinyOut, eAlignLeft, text);  
}

void reset_scroll()
{
scroll_from =1;
scroll_to=1;
rows_needed = 0;
tilesPerRow = 0;
tilesPerCol =0;
}


//*******************************************************************************
//* prepare_listboxes
//*
//*******************************************************************************
void prepare_listboxes() 
{
  int i;
  lbxSetTileType.Clear();
  while (i < TILE_TYPES){
    lbxSetTileType.AddItem(tileTypes[i]);
    i++;
  }
}


//*******************************************************************************
//* room_AfterFadeIn
//*
//*******************************************************************************
function room_AfterFadeIn()
{ 
  player.ChangeView(VCHAR_BLANK);

  show_tiles =true;
  show_items =true;
  show_objects = true;
  show_people = true;
  show_hotspots = true;

  mouse.Visible = true;
  drawGrid = true;
  gDebugging.Visible=false;
  gEditorScene.Visible=true;
  lbxSetTileType.ScrollUp();
  gEditBtm_Tile.ZOrder=0;
  gEditBtm_Itm.ZOrder=0;
  gEditBtm_Obj.ZOrder=0;
  gEditBtm_Nmy.ZOrder=0;
  gEditBtm_Ppl.ZOrder=0;
  gEditBtm_Hsp.ZOrder=0;
  gEditBtm_Set.ZOrder=2;  
  current_tile =0;
  scroll_from =1; 
  scroll_to=1;
  selected_tile =0;
  selected_object =0;
  selected_enemy = -1;
  selected_npc = -1;
  selected_hotspot = 0;

  selected_item = itm_nothing;
  layer = 0;

  TILES.init_tile_sets(1);
  prepare_listboxes();
  
  
  sceneBuffer = DynamicSprite.Create(320, 200);
  editorBuffer = DynamicSprite.Create(318, 96);
  if (leveledit != null && leveledit != "") {
    
    if (TENG.load_map(leveledit, 159, 70, 0, true)) {
      PARALLAX.default_parallax(); 
      TRANS.clear();
      levelLoaded = true;  
      lblEditBtmTilesprite.Text = String.Format("%d",tileset_sprite);
      lblEditBtmTileSet.Text = String.Format("%d",TILES.get_tileset_number());
    }
    else Display("Error, couldn't load level!");
  }
  else {
    TENG.new_map(349, 80, 80, 16, 16);
    leveledit = "";
    PARALLAX.default_parallax(); 
    TRANS.clear();
    levelLoaded = true;  
    lblEditBtmTilesprite.Text = String.Format("%d",tileset_sprite);
    lblEditBtmTileSet.Text = String.Format("%d",TILES.get_tileset_number());
  }
  
}


bool noContextShown() {
  if (!gEditSetObject.Visible && !gEditSetTile.Visible & !gEditDelObject.Visible &!gEditSetNpc.Visible && !gEditDelNpc.Visible
      && !gEditSetHsp.Visible &&!gEditDelHsp.Visible &&!gEditSetImport.Visible && !gEditSetCancel.Visible 
      &&! gEditSetLoad.Visible &&! gEditSetNew.Visible &&! gEditSetSave.Visible && !gEditSetUpdate.Visible)
    return true;
  else return false;
}
//*******************************************************************************
//* doInterface
//*
//*******************************************************************************
void doInterface()
{
	if (isSpaceDown && !IsKeyPressed(eKeySpace) && noContextShown())
	{
    if (!gEditBtm_Tile.Visible)
		{
      if (mouse.Mode != eModePointer) mouse.Mode = eModePointer;
      
      if (!gEditBtm_Tile.Visible) gEditBtm_Tile.Visible = true;
      if (!gEditBtm_Itm.Visible) gEditBtm_Itm.Visible = true;
      if (!gEditBtm_Obj.Visible) gEditBtm_Obj.Visible = true;
      if (!gEditBtm_Nmy.Visible) gEditBtm_Nmy.Visible = true;
      if (!gEditBtm_Ppl.Visible) gEditBtm_Ppl.Visible = true;
      if (!gEditBtm_Hsp.Visible) gEditBtm_Hsp.Visible = true;
      if (!gEditBtm_Set.Visible) gEditBtm_Set.Visible = true;
      if (!gEditorTop.Visible)	gEditorTop.Visible = true;
    }
    else {
			gEditBtm_Tile.Visible = false;
			gEditBtm_Itm.Visible = false; 
			gEditBtm_Obj.Visible = false;
			gEditBtm_Nmy.Visible = false;
			gEditBtm_Ppl.Visible = false;
			gEditBtm_Hsp.Visible = false; 
			gEditBtm_Set.Visible = false;
			gEditorTop.Visible = false;
    }

	}

}


//*******************************************************************************
//* doGridSwitching
//*
//*******************************************************************************
void doMapOverview()
{	
	if (isTabKeyDown && !IsKeyPressed(eKeyTab) && noContextShown()){
		show_map = !show_map;
  }
}

//*******************************************************************************
//* doGridSwitching
//*
//*******************************************************************************
void doGridSwitching()
{	
	if (isGridKeyDown && !IsKeyPressed(eKeyG) && noContextShown())
		drawGrid = !drawGrid;
}

//*******************************************************************************
//* doTileFlip
//*
//*******************************************************************************
void doTileFlip() 
{
  if (selected_tile>0 && noContextShown()) {
    if (isTileFlipXKeyDown && !IsKeyPressed(eKeyX))
      mirror_tile_x =! mirror_tile_x;
    else if (isTileFlipYKeyDown && !IsKeyPressed(eKeyY))
      mirror_tile_y =! mirror_tile_y;
  }
}

//*******************************************************************************
//* doDropper
//*
//*******************************************************************************
void doDropper()
{
  if (toolMode== ToolMode_Tile && isDropperKeyDown && !IsKeyPressed(eKeyE)) {
    if (!gEditBtm_Tile.Visible) {
      if (mouse.Mode == eModePointer) mouse.Mode = eModeDropper;
      else mouse.Mode = eModePointer;
    }
  }
}

//*******************************************************************************
//* clearBrush
//*
//*******************************************************************************
void clearBrush(bool complete)
{
  int i = 0;
  brush_dimx =0;
  brush_dimy =0;
  brush_max_idx = 0;
  while (i<256) {
    brush[i].code=0;
    brush[i].mirror_x=false;
    brush[i].mirror_y=false;
    brush[i].tile=0;
    if (brush[i].spr != null) brush[i].spr.Delete();
    brush[i].spr = null;
    i++;
  }
  if (complete) {
    selected_tile = 0;
    lblEditTileType.Text="0";
    lblEditTypeName.Text="nothing";
    lblEditTileLoop.Text="0";
    lblEditAnisync.Text= "no";
    lblEditTypeName.Text = "";  
  }
}


//*******************************************************************************
//* handleWorldClick
//*
//*******************************************************************************
void handleWorldClick()
{
	if ( (toolMode == ToolMode_Tile && selected_tile >0 ) || (toolMode == ToolMode_Tile && mouse.Mode==eModeDropper) || (toolMode == ToolMode_Tile && brush_max_idx > 0))
	{
  
    // clear brush if needed
    if (mouse.Mode==eModeDropper && brush_max_idx >0) clearBrush(true);

    if (!isLeftMouseButtonDown && mouse.IsButtonDown(eMouseLeft))
    // left mouse button pressed
    {
      toolBufferX = mouse.x; 
      toolBufferY = mouse.y;
    }
    else if (isLeftMouseButtonDown && !mouse.IsButtonDown(eMouseLeft))
    // left mouse button released
    {
      int startTileX = TILES.getTileIndexXFromPoint(toolBufferX, toolBufferY);
      int startTileY = TILES.getTileIndexYFromPoint(toolBufferX, toolBufferY);
      int endTileX = TILES.getTileIndexXFromPoint(mouse.x, mouse.y);
      int endTileY = TILES.getTileIndexYFromPoint(mouse.x , mouse.y);

        
      if (startTileX > endTileX)
      {
        int temp = startTileX;
        startTileX = endTileX;
        endTileX = temp;
      }
      
      if (startTileY > endTileY)
      {
        int temp = startTileY;
        startTileY = endTileY;
        endTileY = temp;
      }
      
      int y = startTileY;
      int tile_cnt = 0;
      
      //eavesdropper selected
      if  (mouse.Mode==eModeDropper) {
        while (y <= endTileY)
        {
          int x = startTileX;
          while (x <= endTileX)
          {
            // just a single tile selected
            if (endTileY - startTileY == 0 && endTileX -startTileX == 0) {
              int temp_tileno = TILES.get_tiletype_number(current_tile, layer);
              
              if (temp_tileno > 0 && tile_sprites[temp_tileno].spr !=null) {
                int tilecode= tile_sprites[temp_tileno].code;
                selected_tile = temp_tileno;
                // Updating the info field with tilecode
                int type = TILES.split_tilecode (eCodepartAttrib, tilecode);
                int loop = TILES.split_tilecode (eCodepartLoop, tilecode);
                int sync = TILES.split_tilecode (eCodepartFlag, tilecode);
                lblEditTileType.Text=String.Format("%d",type);
                lblEditTileLoop.Text=String.Format("%d",loop);
                if (sync >0) lblEditAnisync.Text= "yes";
                else lblEditAnisync.Text="no";
                lblEditTypeName.Text = TILES.get_tiletype_name(type);         
              }               
            }
            // brush mode
            else {
              int temp_tile = TILES.getTileIndexFromTileIndices(x, y);
              int temp_tileno = TILES.get_tiletype_number(temp_tile, layer);
              int temp_mirror = TILES.get_tile_mirroring(temp_tile, layer);
              int temp_slot = TILES.get_tile_sprite(temp_tile, layer);
              
              brush[tile_cnt].code =  tile_sprites[temp_tileno].code;
              brush[tile_cnt].tile =  temp_tileno;
              if (temp_tileno > 0 && temp_slot > 0) brush[tile_cnt].spr  = DynamicSprite.CreateFromExistingSprite(temp_slot);
              else {
                brush[tile_cnt].spr  = DynamicSprite.CreateFromExistingSprite(tile_set.raster);
                brush[tile_cnt].spr.Crop(0, 0, size_tile_x, size_tile_y);
              }
              
              if (temp_mirror == 1 || temp_mirror == 11) {
                brush[tile_cnt].mirror_x = true;
                brush[tile_cnt].spr.Flip(eFlipLeftToRight);

              }
              if (temp_mirror >9){
                brush[tile_cnt].mirror_y = true;
                brush[tile_cnt].spr.Flip(eFlipUpsideDown);
              }
              
              selected_tile = 0;
              lblEditTileType.Text="-";
              lblEditTileLoop.Text="-";
              lblEditAnisync.Text= "-";
              lblEditTypeName.Text = "Brush";      
              tile_cnt++;
            }
            x++;
          }
          y++;
        }
        brush_max_idx = tile_cnt;
        brush_dimx = endTileX - startTileX;
        brush_dimy = endTileY - startTileY;
        
        Mouse.Mode = eModePointer;
      }
      // draw tile or brush
      else {
        // Brush
        if (brush_max_idx >0) {
          y = 0; 
          int x   = 0;
          int idx = 0;
          
          while (y <= brush_dimy) {
            x= 0;
            while ( x <= brush_dimx) {
              TILES.create_tile(endTileX+x, endTileY+y, brush[idx].code, layer, brush[idx].tile, brush[idx].mirror_x, brush[idx].mirror_y );
              idx ++;
              x++;
            }
            y++;
          }
        }
        else {
          //draw tile
          while (y <= endTileY) {
            int x = startTileX;
            
            while (x <= endTileX) {
              TILES.create_tile(x, y, tile_sprites[selected_tile].code, layer, selected_tile, mirror_tile_x, mirror_tile_y);					 
              x++;
            }
          
            y++;
          }
        }
      }
    }
    else if (!isRightMouseButtonDown && mouse.IsButtonDown(eMouseRight))
    // right mouse button pressed
    {
      toolBufferX = mouse.x;
      toolBufferY = mouse.y;
    }
    else if (isRightMouseButtonDown && !mouse.IsButtonDown(eMouseRight))
    // right mouse button released
    {
      int startTileX = TILES.getTileIndexXFromPoint(toolBufferX, toolBufferY);
      int startTileY = TILES.getTileIndexYFromPoint(toolBufferX, toolBufferY);
      int endTileX = TILES.getTileIndexXFromPoint(mouse.x, mouse.y);
      int endTileY = TILES.getTileIndexYFromPoint(mouse.x, mouse.y);
      
      if (startTileX > endTileX)
      {
        int temp = startTileX;
        startTileX = endTileX;
        endTileX = temp;
      }
      
      if (startTileY > endTileY)
      {
        int temp = startTileY;
        startTileY = endTileY;
        endTileY = temp;
      }
      
      int y = startTileY;
      
      //brush delete
      if (brush_max_idx > 0) {
        y = 0; 
        int x   = 0;
        while (y <= brush_dimy) {
          x= 0;
          while ( x <= brush_dimx) {
            TILES.create_tile(endTileX+x, endTileY+y, 0, layer, 0, false, false);
            x++;
          }
          y++;
        }        
      }
      else {
        // regular removal
        while (y <= endTileY)
        {
          int x = startTileX;
          while (x <= endTileX)
          {
            TILES.create_tile(x, y, 0, layer, 0, false, false);
            x++;
          }
        
          y++;
        }
      }
    } 
    
  }
  //Item-Mode: Items
  else if (toolMode == ToolMode_Item && selected_item > 0) {
    toolBufferX = mouse.x; 
    toolBufferY = mouse.y;    
    if (isLeftMouseButtonDown && !mouse.IsButtonDown(eMouseLeft) && selected_item >0) {
      ITM.spawn_item(current_tile, item_types[selected_item].loop, 0, selected_item, item_hidden , false);      
    }
    else if (isRightMouseButtonDown && !mouse.IsButtonDown(eMouseRight)) {
      int remove_itm_idx = ITM.get_item_at (mouse.x , mouse.y );
      if (remove_itm_idx >-1)ITM.clear_item(remove_itm_idx);
    }
  }
  //Item-Mode: Platforms and Waypoints
  else if (toolMode == ToolMode_Item && selected_item < -99) {
    toolBufferX = mouse.x; 
    toolBufferY = mouse.y;     
    if (isLeftMouseButtonDown && !mouse.IsButtonDown(eMouseLeft)) {
      if (selected_item == -100 && PFORM.check_platform_at(mouse.x , mouse.y, false) == -1) PFORM.create_platfrom(current_tile, 1);
      else if (selected_item == -101 && PFORM.check_platform_at(mouse.x , mouse.y, false) == -1) PFORM.create_platfrom(current_tile, 2);
      else if (selected_item == -102 && WPOINT.check_waypoint_at(current_tile)==-1) WPOINT.create_waypoint(0, 0, current_tile, eTengDirNull);
      else if (selected_item == -103 && WPOINT.check_waypoint_at(current_tile)==-1) EGO.set_spawn(current_tile);
      else if (selected_item == -104 && WPOINT.check_waypoint_at(current_tile)==-1) WPOINT.create_waypoint(0, 0, current_tile, eTengDirUp);
      else if (selected_item == -105 && WPOINT.check_waypoint_at(current_tile)==-1) WPOINT.create_waypoint(0, 0, current_tile, eTengDirDown);
      else if (selected_item == -106 && WPOINT.check_waypoint_at(current_tile)==-1) WPOINT.create_waypoint(0, 0, current_tile, eTengDirLeft);
      else if (selected_item == -107 && WPOINT.check_waypoint_at(current_tile)==-1) WPOINT.create_waypoint(0, 0, current_tile, eTengDirRight);
      
    }
    else if (isRightMouseButtonDown && !mouse.IsButtonDown(eMouseRight)) {
      if (selected_item == -102 || (selected_item >=-107 && selected_item <=-104)) {
        int remove_wp_idx = WPOINT.check_waypoint_at(current_tile);
        if (remove_wp_idx >-1) WPOINT.clear_waypoint(remove_wp_idx);
      }
      else {
        int remove_pform_idx = PFORM.check_platform_at(mouse.x , mouse.y, false);
        if (remove_pform_idx >-1)PFORM.clear_platform(remove_pform_idx);
      }
    }
  }  
  //Item-Mode: Object
  else if (toolMode == ToolMode_Object && selected_object > 0) {
    toolBufferX = mouse.x; 
    toolBufferY = mouse.y;     
    if (isLeftMouseButtonDown && !mouse.IsButtonDown(eMouseLeft) && selected_object >0) {
      ITM.set_item_XY_from_tile(t_object_id[selected_object], current_tile, false);
    }
    else if (isRightMouseButtonDown && !mouse.IsButtonDown(eMouseRight)) {
      ITM.set_item_XY_from_tile(t_object_id[selected_object], -1, false);
    }
  }
  // People-Mode: Enemies
  else if (toolMode == ToolMode_Enemy && selected_enemy > -1) {
    toolBufferX = mouse.x; 
    toolBufferY = mouse.y;     
    if (isLeftMouseButtonDown && !mouse.IsButtonDown(eMouseLeft)) {
      PEOPLE.spawn_enemy(current_tile, selected_enemy);
    }
    else if (isRightMouseButtonDown && !mouse.IsButtonDown(eMouseRight)) {
      int remove_ppl_idx = PEOPLE.get_people_at (mouse.x , mouse.y );
      if (remove_ppl_idx >-1) PEOPLE.clear_people(remove_ppl_idx);
    }    
  }
  // People-Mode: NPCs
  else if (toolMode == ToolMode_People && selected_npc > -1) {
    toolBufferX = mouse.x; 
    toolBufferY = mouse.y;     
    if (isLeftMouseButtonDown && !mouse.IsButtonDown(eMouseLeft)) {
      PEOPLE.set_people_XY_from_tile(selected_npc, current_tile, false);
    }
    else if (isRightMouseButtonDown && !mouse.IsButtonDown(eMouseRight)) {
      PEOPLE.set_people_XY_from_tile(selected_npc, -1);
    }    
  }
  //Hotspots
  if (toolMode == ToolMode_Hotspot && selected_hotspot >0)
	{
		if (!isLeftMouseButtonDown && mouse.IsButtonDown(eMouseLeft))
		// left mouse button pressed
		{
			toolBufferX = mouse.x; 
			toolBufferY = mouse.y;
		}
    else if (isLeftMouseButtonDown && !mouse.IsButtonDown(eMouseLeft))
		// left mouse button released
		{
			int startTileX = TILES.getTileIndexXFromPoint(toolBufferX, toolBufferY);
			int startTileY = TILES.getTileIndexYFromPoint(toolBufferX, toolBufferY);
			int endTileX = TILES.getTileIndexXFromPoint(mouse.x, mouse.y);
			int endTileY = TILES.getTileIndexYFromPoint(mouse.x , mouse.y);
			
			if (startTileX > endTileX)
			{
				int temp = startTileX;
				startTileX = endTileX;
				endTileX = temp;
			}
			
			if (startTileY > endTileY)
			{
				int temp = startTileY;
				startTileY = endTileY;
				endTileY = temp;
			}
			
			int y = startTileY;
			while (y <= endTileY)
			{
				int x = startTileX;
				while (x <= endTileX)
				{
          int temp_tile = TILES.getTileIndexFromTileIndices(x, y);
          HSP.spawn_hotspot(temp_tile, selected_hotspot, lblEditHspHidden.Text.AsInt, lblEditHspName.Text);
					x++;
				}
			
				y++;
			}
		}
		else if (!isRightMouseButtonDown && mouse.IsButtonDown(eMouseRight))
		// right mouse button pressed
		{
			toolBufferX = mouse.x;
			toolBufferY = mouse.y;
		}
		else if (isRightMouseButtonDown && !mouse.IsButtonDown(eMouseRight))
		// right mouse button released
		{
			int startTileX = TILES.getTileIndexXFromPoint(toolBufferX, toolBufferY);
			int startTileY = TILES.getTileIndexYFromPoint(toolBufferX, toolBufferY);
			int endTileX = TILES.getTileIndexXFromPoint(mouse.x, mouse.y);
			int endTileY = TILES.getTileIndexYFromPoint(mouse.x, mouse.y);
			
			if (startTileX > endTileX)
			{
				int temp = startTileX;
				startTileX = endTileX;
				endTileX = temp;
			}
			
			if (startTileY > endTileY)
			{
				int temp = startTileY;
				startTileY = endTileY;
				endTileY = temp;
			}
			
			int y = startTileY;
			while (y <= endTileY)
			{
				int x = startTileX;
				while (x <= endTileX)
				{
          int temp_tile = TILES.getTileIndexFromTileIndices(x, y);
          int return_hsp_idx = HSP.get_hotspot_at ( temp_tile );
          if (return_hsp_idx >0 && return_hsp_idx < MAX_HOTSPOTS ) HSP.clear_t_hotspot(return_hsp_idx);
					x++;
				}
			
				y++;
			}
		}  
  }  
}


//*******************************************************************************
//* handleInterfaceClickEditTile
//*
//*******************************************************************************
void handleInterfaceClickEditTile() 
{
  int i, j, k=0;
  int tile_idx;
  int tilecode;
  int type, loop, sync;
  int tilearea_x =52;
  int tilearea_y =108;
  

  // Scroll Arrows
  if (mouse.x >= 311 && mouse.x <= 316) {
    if (scrollDownActive && (mouse.y >= gEditBtm_Tile.Y + 79 && mouse.y <= gEditBtm_Tile.Y + 94 )) {
      scroll_from ++;
      return;
    }
    else if (scrollUpActive && (mouse.y >= gEditBtm_Tile.Y + 3 && mouse.y <= gEditBtm_Tile.Y + 18 )) {
      scroll_from --;
      return;
    }
  }
  
  // Toggle Layer Button
  if ((mouse.x >= 3 && mouse.x <= 32) && mouse.y >= gEditBtm_Tile.Y+13 && mouse.y <= gEditBtm_Tile.Y+20) {
    if (layer==0) layer =1;
    else layer =0;
  }
  
  // Layer Visibility Button
  if ((mouse.x >= 36 && mouse.x <= 48) && mouse.y >= gEditBtm_Tile.Y+13 && mouse.y <= gEditBtm_Tile.Y+20)
    show_tiles = !show_tiles;
  
  //TileGrid
  j= scroll_from;
  i=1;
  
  while (j<=rows_needed - scroll_to) {
    //rows
    if (mouse.y - gEditBtm_Tile.Y -10 >= 3+k+(k * size_tile_y) && mouse.y - gEditBtm_Tile.Y -10<= 3+k+(k * size_tile_y)+size_tile_y) {
      while (i<=tilesPerRow) {
        tile_idx = ((j-1) * tilesPerRow)+i;  
  
          if ( (mouse.x - tilearea_x>= i+((i-1)*size_tile_x)&& mouse.x - tilearea_x <=i+((i-1)*size_tile_x)+size_tile_x)) {
            if (tile_sprites[tile_idx].spr !=null) {
            tilecode= tile_sprites[tile_idx].code;
            selected_tile = tile_idx;
            // Updating the info field with tilecode
            type = TILES.split_tilecode (eCodepartAttrib, tilecode);
            loop = TILES.split_tilecode (eCodepartLoop, tilecode);
            sync = TILES.split_tilecode (eCodepartFlag, tilecode);
            lblEditTileType.Text=String.Format("%d",type);
            lblEditTileLoop.Text=String.Format("%d",loop);
            if (sync >0) lblEditAnisync.Text= "yes";
            else lblEditAnisync.Text="no";
            lblEditTypeName.Text = TILES.get_tiletype_name(type);  
            j = rows_needed - scroll_to;
            i = tilesPerRow;            
          }
        }
        i++;
      }
    }
    i=1;
    k++;
    j++;
  }
  
  // remove_brush
  if (selected_tile!=0 && brush_max_idx > 0) clearBrush(false);
  
  // Edit button
  if (selected_tile!=0) {
    if ((isRightMouseButtonDown)||((mouse.x >= 3 && mouse.x <= 20) && mouse.y >= gEditBtm_Tile.Y+85 && mouse.y <= gEditBtm_Tile.Y+92)) {
      //lblSetTileInfo.Text=lblEditTypeName.Text;//String.Format("%d",tile_sprites[selected_tile].code);
      lbxSetTileType.SelectedIndex = lblEditTileType.Text.AsInt;
      if (lblEditTileType.Text.AsInt >0 )lbxSetTileType.TopItem = lblEditTileType.Text.AsInt;
      tbxSetTileLoop.Text=lblEditTileLoop.Text;
      if (lblEditAnisync.Text == "yes") {
        lblSetTileAnisyncInfo.Text = "yes";
        lblSetTileAnisync.Text = "1";
      }
      else {
        lblSetTileAnisyncInfo.Text = "no";
        lblSetTileAnisync.Text = "0";      
      }
      
      gEditSetTile.Visible=true;
    }
  }

}


//*******************************************************************************
//* handleInterfaceClickEditItem
//*
//*******************************************************************************
void handleInterfaceClickEditItem()
{
  int i, j, k=0;
  int itm_idx;
  int tilearea_x =52;
  int tilearea_y =108; 
  
  // Scroll Arrows
  if (mouse.x >= 311 && mouse.x <= 316) {
    if (scrollDownActive && (mouse.y >= gEditBtm_Tile.Y + 39 && mouse.y <= gEditBtm_Tile.Y + 49 )) {
      scroll_from ++;
      //Display ("Down");
      return;
    }
    else if (scrollUpActive && (mouse.y >= gEditBtm_Tile.Y + 3 && mouse.y <= gEditBtm_Tile.Y + 18 )) {
      //Display ("Up");
      scroll_from --;
      return;
    }
  }
  
  // Set hidden Button
  if ( (mouse.x >= 2 && mouse.x<=33) && (mouse.y >= gEditBtm_Tile.Y +21 &&  mouse.y <= gEditBtm_Tile.Y + 29))item_hidden= !item_hidden;
  
  // Layer Visibility Button
  if ((mouse.x >= 36 && mouse.x <= 48) && mouse.y >= gEditBtm_Tile.Y+13 && mouse.y <= gEditBtm_Tile.Y+20)
    show_items = !show_items;

  //Item Grid
  j= scroll_from;
  i=1;
  
  while (j<=rows_needed - scroll_to) {
    //rows
    if (mouse.y - gEditBtm_Tile.Y -9 >= 3+k+(k * size_tile_y) && mouse.y - gEditBtm_Tile.Y -9 <= 3+k+(k * size_tile_y)+size_tile_y) {
      while (i<=tilesPerRow) {
        itm_idx = ((j-1) * tilesPerRow)+i;  
  
          if ( (mouse.x - tilearea_x>= i*2+((i-1)*size_tile_x)&& mouse.x - tilearea_x <=i*2+((i-1)*size_tile_x)+size_tile_x)) {
            if (item_types[itm_idx].loop !=0) {
              selected_item = itm_idx;
              lblEditItemType.Text = item_types[itm_idx].name; 
              j = rows_needed - scroll_to;
              i = tilesPerRow;
            }
          }
          i++;
        }
      }
    i=1;
    k++;
    j++;
  }
  // Platforms and Waypoints
  if (mouse.y >= 58 + gEditBtm_Tile.Y && mouse.y <= gEditBtm_Tile.Y + 58+ Game.SpriteWidth[tile_set.platform_vert]) {
    if (mouse.x >=53 && mouse.x <= 53 + Game.SpriteWidth[tile_set.platform_hori]) {
      lblEditItemType.Text = "Horizontal Platform";
      selected_item = -100;
    }
    else if (mouse.x >=55  + Game.SpriteWidth[tile_set.platform_hori] && mouse.x <= 56 + Game.SpriteWidth[tile_set.platform_hori]*2) {
      lblEditItemType.Text = "Vertical Platform";
      selected_item = -101;
    }
    else if ((mouse.x >=57  + Game.SpriteWidth[tile_set.platform_hori]*2) && mouse.x <= 56 + Game.SpriteWidth[tile_set.platform_hori]*3) {
      lblEditItemType.Text = "Player Spawn";
      selected_item = -103;
    }
    else if ((mouse.x >=59  + Game.SpriteWidth[tile_set.platform_hori]*3) && mouse.x <= 56 + Game.SpriteWidth[tile_set.platform_hori]*4) {
      lblEditItemType.Text = "WP Stop";
      selected_item = -102;
    }
    else if ((mouse.x >=61  + Game.SpriteWidth[tile_set.platform_hori]*4-5) && mouse.x <= 61 + Game.SpriteWidth[tile_set.platform_hori]*5-5) {
      lblEditItemType.Text = "WP Up";
      selected_item = -104;
    }
    else if ((mouse.x >=63  + Game.SpriteWidth[tile_set.platform_hori]*5-10) && mouse.x <= 63 + Game.SpriteWidth[tile_set.platform_hori]*6-10) {
      lblEditItemType.Text = "WP Down";
      selected_item = -105;
    }
    else if ((mouse.x >=65  + Game.SpriteWidth[tile_set.platform_hori]*6-15) && mouse.x <= 65 + Game.SpriteWidth[tile_set.platform_hori]*7-15) {
      lblEditItemType.Text = "WP Left";
      selected_item = -106;
    }
    else if ((mouse.x >=67  + Game.SpriteWidth[tile_set.platform_hori]*7-20) && mouse.x <= 67 + Game.SpriteWidth[tile_set.platform_hori]*8-20) {
      lblEditItemType.Text = "WP Right";
      selected_item = -107;
    }       
  }

}

//*******************************************************************************
//* handleInterfaceClickEditObject
//*
//*******************************************************************************
void handleInterfaceClickEditObject() 
{
  int i, j, k=0;

  int object_idx;
  int tilearea_x =52;
  int tilearea_y =108;
  
  // Scroll Arrows
  if (mouse.x >= 311 && mouse.x <= 316) {
    if (scrollDownActive && (mouse.y >= gEditBtm_Tile.Y + 79 && mouse.y <= gEditBtm_Tile.Y + 94 )) {
      scroll_from ++;
      return;
    }
    else if (scrollUpActive && (mouse.y >= gEditBtm_Tile.Y + 3 && mouse.y <= gEditBtm_Tile.Y + 18 )) {
      scroll_from --;
      return;
    }
  }
  
  // Layer Visibility Button
  if ((mouse.x >= 36 && mouse.x <= 48) && mouse.y >= gEditBtm_Tile.Y+13 && mouse.y <= gEditBtm_Tile.Y+20)
    show_objects = !show_objects;
    
  //TileGrid
  j= scroll_from;
  i=1;
  
  while (j<=rows_needed - scroll_to) {
    //rows
    if (mouse.y - gEditBtm_Tile.Y -10 >= 3+k+(k * size_tile_y) && mouse.y - gEditBtm_Tile.Y -10<= 3+k+(k * size_tile_y)+size_tile_y) {
      while (i<=tilesPerRow) {
        object_idx = ((j-1) * tilesPerRow)+i;  
        //Display ("obj idx %d", object_idx);
		      if ( (mouse.x - tilearea_x>= i*2+((i-1)*size_tile_x)&& mouse.x - tilearea_x <=i*2+((i-1)*size_tile_x)+size_tile_x)) {          
            if (object_idx < MAX_ITEMS && t_object_id[object_idx] >0) {
              selected_object = object_idx;
              if (item[ t_object_id[object_idx] ].name != null) lblEditObjName.Text = item[ t_object_id[object_idx] ].name;
              else lblEditObjName.Text = "";
              if (item[ t_object_id[object_idx] ].usable == true) lblEditObjAct.Text = "yes";
              else lblEditObjAct.Text = "no";
              if (item[ t_object_id[object_idx] ].is_solid == true) lblEditObjIsSolid.Text = "yes";
              else lblEditObjIsSolid.Text = "no";
              if (item[ t_object_id[object_idx] ].in_foreground == true) lblEditObjIsFG.Text = "yes";
              else lblEditObjIsFG.Text = "no";              
              if (item[ t_object_id[object_idx] ].ignore_gravity == true) lblEditObjGravity.Text = "yes";
              else lblEditObjGravity.Text = "no";
              j = rows_needed - scroll_to;
              i = tilesPerRow;            
            }
          }
        
        i++;
      }
    }
    i=1;
    k++;
    j++;
  }
  
  // New button
  if ((mouse.x >= 3 && mouse.x <= 20) && mouse.y >= gEditBtm_Tile.Y+82 && mouse.y <= gEditBtm_Tile.Y+89) {
    tbxSetObjectName.Text ="";
    tbxSetObjectShownName.Text ="";
    tbxSetObjSprite.Text = "";
    lblSetObjIsSolidInfo.Text = "no";
    lblSetObjIsSolid.Text = "0";
    lblSetObjIsFGInfo.Text = "no";
    lblSetObjIsFG.Text = "0";
    
    lblSetObjActInfo.Text = "no";
    lblSetObjAct.Text = "0";
    lblSetObjGravityInfo.Text = "no";
    lblSetObjGravity.Text = "0"; 
    tbxSetObjectName.Enabled=true;
    tbxSetObjectShownName.Enabled=false;
    tbxSetObjSprite.Enabled=false;
    btnSetObjOk.Text = "New";
    gEditSetObject.Visible=true;      
  }
  if (selected_object!=0) {
    // Edit Button
    if ((isRightMouseButtonDown)||((mouse.x >= 22 && mouse.x <= 37) && mouse.y >= gEditBtm_Tile.Y+82 && mouse.y <= gEditBtm_Tile.Y+89)) {
      tbxSetObjectName.Text = lblEditObjName.Text;
      tbxSetObjectShownName.Text = ITM.get_object_shown_name(selected_object);
      tbxSetObjSprite.Text = String.Format("%d",item[ t_object_id[selected_object] ].obj_sprite);
      
      if (item[ t_object_id[selected_object] ].is_solid == true) {
        lblSetObjIsSolidInfo.Text = "yes";
        lblSetObjIsSolid.Text = "1";
      }
      else {
        lblSetObjIsSolidInfo.Text = "no";
        lblSetObjIsSolid.Text = "0";
      }
      
      if (item[ t_object_id[selected_object] ].usable == true) {
        lblSetObjActInfo.Text = "yes";
        lblSetObjAct.Text = "1";
      }
      else {
        lblSetObjActInfo.Text = "no";
        lblSetObjAct.Text = "0";
      }  
      
      if (item[ t_object_id[selected_object] ].in_foreground == true) {
        lblSetObjIsFGInfo.Text = "yes";
        lblSetObjIsFG.Text = "1";
      }
      else {
        lblSetObjIsFGInfo.Text = "no";
        lblSetObjIsFG.Text = "0";
      }  
      
      if (item[ t_object_id[selected_object] ].ignore_gravity == true) {
        lblSetObjGravityInfo.Text = "yes";
        lblSetObjGravity.Text = "1";
      }
      else {
        lblSetObjGravityInfo.Text = "no";
        lblSetObjGravity.Text = "0";
      }       
      tbxSetObjectName.Enabled=true;
      tbxSetObjectShownName.Enabled=false;
      
      tbxSetObjSprite.Enabled=false;
      btnSetObjOk.Text = "Edit";
      gEditSetObject.Visible=true;
    }
    // Del Button
    else if ((mouse.x >= 3 && mouse.x <= 20) && mouse.y >= gEditBtm_Tile.Y+91 && mouse.y <= gEditBtm_Tile.Y+98) {
      gEditDelObject.Visible=true;
    }
  }  
}


//*******************************************************************************
//* handleInterfaceClickEditEnemy
//*
//*******************************************************************************
void handleInterfaceClickEditEnemy() 
{
 int i, j, k=0;

  int people_idx;
  
  int tilearea_x =52;
  int tilearea_y =108;
  
  // Scroll Arrows
  if (mouse.x >= 311 && mouse.x <= 316) {
    if (scrollDownActive && (mouse.y >= gEditBtm_Tile.Y + 79 && mouse.y <= gEditBtm_Tile.Y + 94 )) {
      scroll_from ++;
      return;
    }
    else if (scrollUpActive && (mouse.y >= gEditBtm_Tile.Y + 3 && mouse.y <= gEditBtm_Tile.Y + 18 )) {
      scroll_from --;
      return;
    }
  }

  // Layer Visibility Button
  if ((mouse.x >= 36 && mouse.x <= 48) && mouse.y >= gEditBtm_Tile.Y+13 && mouse.y <= gEditBtm_Tile.Y+20) {
    show_people = !show_people;
    if (!show_people) PEOPLE.remove_all_people();
  }
    
   //TileGrid
  j= scroll_from;
  i=1;
  
  while (j<=rows_needed - scroll_to) {
    //rows
    if (mouse.y - gEditBtm_Tile.Y -10 >= 3+k+(k * size_tile_y) && mouse.y - gEditBtm_Tile.Y -10<= 3+k+(k * size_tile_y)+size_tile_y) {
      while (i<=tilesPerRow) {
        people_idx = ((j-1) * tilesPerRow)+i+1;
          if ( (mouse.x - tilearea_x>= i*2+((i-1)*size_tile_x)&& mouse.x - tilearea_x <=i*2+((i-1)*size_tile_x)+size_tile_x)) {
            if (people_idx < MAX_ITEMS && people_types[people_idx].name!= null ) {
              selected_enemy = people_idx;
              selected_npc = -1;
              lblEditNmyName.Text = people_types[people_idx].name;
              j = rows_needed - scroll_to;
              i = tilesPerRow;            
            } 
          }
        
        i++;
      }
    }
    i=1;
    k++;
    j++;
  }
}

//*******************************************************************************
//* handleInterfaceClickEditPeople
//*
//*******************************************************************************
void handleInterfaceClickEditPeople() 
{
  int i, j, k=0;

  int people_idx;
  
  int tilearea_x =52;
  int tilearea_y =108;
  
  // Scroll Arrows
  if (mouse.x >= 311 && mouse.x <= 316) {
    if (scrollDownActive && (mouse.y >= gEditBtm_Tile.Y + 79 && mouse.y <= gEditBtm_Tile.Y + 94 )) {
      scroll_from ++;
      return;
    }
    else if (scrollUpActive && (mouse.y >= gEditBtm_Tile.Y + 3 && mouse.y <= gEditBtm_Tile.Y + 18 )) {
      scroll_from --;
      return;
    }
  }

  // Layer Visibility Button
  if ((mouse.x >= 36 && mouse.x <= 48) && mouse.y >= gEditBtm_Tile.Y+13 && mouse.y <= gEditBtm_Tile.Y+20) {
    show_people = !show_people;
    if (!show_people) PEOPLE.remove_all_people();
  }
    
  //TileGrid
  j= scroll_from;
  i=1;
  
  while (j<=rows_needed - scroll_to) {
    //rows
    if (mouse.y - gEditBtm_Tile.Y -10 >= 3+k+(k * size_tile_y) && mouse.y - gEditBtm_Tile.Y -10<= 3+k+(k * size_tile_y)+size_tile_y) {
      while (i<=tilesPerRow) {
        people_idx = ((j-1) * tilesPerRow)+i;
        
          if ( (mouse.x - tilearea_x>= i*2+((i-1)*size_tile_x)&& mouse.x - tilearea_x <=i*2+((i-1)*size_tile_x)+size_tile_x)) {
            if (people_idx < MAX_ITEMS && people_id[people_idx]>-1 ) {
              selected_npc = people_id[people_idx];
              selected_enemy = -1;
              if (people[ people_id[people_idx]].name != null) lblEditPplName.Text =people[ people_id[people_idx]].name;
              else lblEditPplName.Text =  "No Name";
              if (people[ people_id[people_idx]].is_interactable) lblEditPplAct.Text = "yes";
              else lblEditPplAct.Text = "no";
              j = rows_needed - scroll_to;
              i = tilesPerRow;            
            } 
          }
        
        i++;
      }
    }
    i=1;
    k++;
    j++;
  }
  
  // New button
  if ((mouse.x >= 3 && mouse.x <= 35) && mouse.y >= gEditBtm_Tile.Y+82 && mouse.y <= gEditBtm_Tile.Y+89) {
    tbxSetNpcName.Text = "";
    tbxSetNpcName.Enabled = true;
    tbxSetNpcView.Text ="";
    tbxSetNpcView.Enabled = false;
    tbxSetNpcTalkView.Text ="-1";
    tbxSetNpcTalkView.Enabled = false;
    tbxSetNpcTalkColor.Text = "15";
    tbxSetNpcTalkColor.Enabled = false;
    tbxSetNpcIdleView.Text ="-1";
    tbxSetNpcIdleView.Enabled = false;
    lblSetNpcActInfo.Text = "no";
    lblSetNpcAct.Text = "0";
    lblSetNpcHostileInfo.Text = "no";
    lblSetNpcHostile.Text = "0";
    btnSetNpcOk.Text = "New";
    gEditSetNpc.Visible = true;

  }
  if (selected_npc>0) {
    // Edit Button
    if ((isRightMouseButtonDown)||((mouse.x >= 3 && mouse.x <= 20) && mouse.y >= gEditBtm_Tile.Y+91 && mouse.y <= gEditBtm_Tile.Y+98)) {
      tbxSetNpcName.Text = lblEditPplName.Text;
      tbxSetNpcView.Text = String.Format ("%d",people[selected_npc].view);
      tbxSetNpcTalkView.Text = String.Format ("%d",people[selected_npc].talk_view);
      tbxSetNpcTalkColor.Text = String.Format ("%d",people[selected_npc].talk_color);
      tbxSetNpcIdleView.Text = String.Format ("%d",people[selected_npc].idle_view);
      tbxSetNpcName.Enabled = true;
      tbxSetNpcView.Enabled = false;
      tbxSetNpcTalkView.Enabled = false;
      tbxSetNpcTalkColor.Enabled = false;
      tbxSetNpcIdleView.Enabled = false;
      
      if (people[selected_npc].is_interactable) {
        lblSetNpcActInfo.Text = "yes";
        lblSetNpcAct.Text = "1";
      }
      else {
        lblSetNpcActInfo.Text = "no";
        lblSetNpcAct.Text = "0";        
      }
      if (people[selected_npc].is_hostile) {
        lblSetNpcHostileInfo.Text = "yes";
        lblSetNpcHostile.Text = "1";
      }
      else {
        lblSetNpcHostileInfo.Text = "no";
        lblSetNpcHostile.Text = "0";        
      }      
      btnSetNpcOk.Text = "Edit";
      gEditSetNpc.Visible = true;
    }
    // Del Button
    else if ((mouse.x >= 22 && mouse.x <= 37) && mouse.y >= gEditBtm_Tile.Y+91 && mouse.y <= gEditBtm_Tile.Y+98) {
      gEditDelNpc.Visible=true;
    }
  }  
}



//*******************************************************************************
//* handleInterfaceClickEditHotspot
//*
//*******************************************************************************
void handleInterfaceClickEditHotspot() 
{
  int i, j, k=0;

  int hsp_idx;
  int tilearea_x =52;
  int tilearea_y =108;
  
  // Scroll Arrows
  if (mouse.x >= 311 && mouse.x <= 316) {
    if (scrollDownActive && (mouse.y >= gEditBtm_Tile.Y + 79 && mouse.y <= gEditBtm_Tile.Y + 94 )) {
      scroll_from ++;
      return;
    }
    else if (scrollUpActive && (mouse.y >= gEditBtm_Tile.Y + 3 && mouse.y <= gEditBtm_Tile.Y + 18 )) {
      scroll_from --;
      return;
    }
  }


  // Layer Visibility Button
  if ((mouse.x >= 36 && mouse.x <= 48) && mouse.y >= gEditBtm_Tile.Y+13 && mouse.y <= gEditBtm_Tile.Y+20)
    show_hotspots = !show_hotspots;
    
  //TileGrid
  j= scroll_from;
  i=1;
    
  while (j<=rows_needed - scroll_to) {
    //rows
    if (mouse.y - gEditBtm_Tile.Y -10 >= 3+k+(k * size_tile_y) && mouse.y - gEditBtm_Tile.Y -10<= 3+k+(k * size_tile_y)+size_tile_y) {
      while (i<=tilesPerRow) {
        hsp_idx = ((j-1) * tilesPerRow)+i;  
        //Display ("obj idx %d", object_idx);
		      if ( (mouse.x - tilearea_x>= i*2+((i-1)*size_tile_x)&& mouse.x - tilearea_x <=i*2+((i-1)*size_tile_x)+size_tile_x)) {          
            if (hsp_idx < MAX_HOTSPOTS && t_hotspot_id[hsp_idx] >0) {
              selected_hotspot = hsp_idx;
              if (t_hotspot[t_hotspot_id[selected_hotspot]].name!= null) lblEditHspName.Text = t_hotspot[t_hotspot_id[selected_hotspot]].name;
              else  lblEditHspName.Text = "";
              
              if (t_hotspot[t_hotspot_id[selected_hotspot]].hidden ==true) {
                lblEditHspHiddenInfo.Text = "yes";
                lblEditHspHidden.Text = "1";
              }
              else {
                lblEditHspHiddenInfo.Text = "no";
                lblEditHspHidden.Text = "0";
              }

              j = rows_needed - scroll_to;
              i = tilesPerRow;     
              
            }
          }
        
        i++;
      }
    }
    i=1;
    k++;
    j++;
  }
  
  // New button
  if ((mouse.x >= 3 && mouse.x <= 20) && mouse.y >= gEditBtm_Tile.Y+82 && mouse.y <= gEditBtm_Tile.Y+89) {
    tbxSetHspName.Text = "";
    tbxSetHspShownName.Text = "";
    tbxSetHspShownName.Enabled = false;
    lblSetHspHiddenInfo.Text = "no";
    lblSetHspHidden.Text = "0";
    btnSetHspOk.Text = "New";
    gEditSetHsp.Visible = true;    
  }
  if (selected_hotspot!=0) {
    // Edit Button
    if ((isRightMouseButtonDown)||((mouse.x >= 22 && mouse.x <= 37) && mouse.y >= gEditBtm_Tile.Y+82 && mouse.y <= gEditBtm_Tile.Y+89)) {
      tbxSetHspName.Text = lblEditHspName.Text;
      tbxSetHspShownName.Text = HSP.get_hotspot_shown_name(selected_hotspot, false);
      tbxSetHspName.Enabled = true;
      tbxSetHspShownName.Enabled = false;
      if (t_hotspot[t_hotspot_id[selected_hotspot]].hidden ==true) {
        lblSetHspHiddenInfo.Text = "yes";
        lblSetHspHidden.Text = "1";
      }
      else {
        lblSetHspHiddenInfo.Text = "no";
        lblSetHspHidden.Text = "0";        
      }
      btnSetHspOk.Text = "Edit";
      gEditSetHsp.Visible = true;
    }
    // Del Button
    else if ((mouse.x >= 3 && mouse.x <= 20) && mouse.y >= gEditBtm_Tile.Y+91 && mouse.y <= gEditBtm_Tile.Y+98) {
      gEditDelHsp.Visible=true;
    }
  } 
}


//*******************************************************************************
//* handleInterfaceClick
//*
//*******************************************************************************
void handleInterfaceClick()
{  
  // Interface Tabs
	if (mouse.y >= gEditBtm_Tile.Y && mouse.y <= gEditBtm_Tile.Y + 7 )
	{
    reset_scroll();
    // TileTab
		if (mouse.x >= 4 && mouse.x <= 25) { 
      gEditBtm_Tile.ZOrder=2;
      gEditBtm_Itm.ZOrder=0;
      gEditBtm_Obj.ZOrder=0;
      gEditBtm_Nmy.ZOrder=0;
      gEditBtm_Ppl.ZOrder=0;
      gEditBtm_Hsp.ZOrder=0;
      gEditBtm_Set.ZOrder=0;      
    }
    // ItemTab
    else if (mouse.x >= 28 && mouse.x <= 77) {      
      gEditBtm_Tile.ZOrder=0;
      gEditBtm_Itm.ZOrder=2;
      gEditBtm_Obj.ZOrder=0;
      gEditBtm_Nmy.ZOrder=0;
      gEditBtm_Ppl.ZOrder=0;
      gEditBtm_Hsp.ZOrder=0;
      gEditBtm_Set.ZOrder=0;        
    }
    // ObjectTab
    else if (mouse.x >= 80 && mouse.x <= 116) {
      gEditBtm_Tile.ZOrder=0;
      gEditBtm_Itm.ZOrder=0;
      gEditBtm_Obj.ZOrder=2;
      gEditBtm_Nmy.ZOrder=0;
      gEditBtm_Ppl.ZOrder=0;
      gEditBtm_Hsp.ZOrder=0;
      gEditBtm_Set.ZOrder=0;        
    }
    // EnemyTab
    else if (mouse.x >= 119 && mouse.x <= 148) {
      gEditBtm_Tile.ZOrder=0;
      gEditBtm_Itm.ZOrder=0;
      gEditBtm_Obj.ZOrder=0;
      gEditBtm_Nmy.ZOrder=2;
      gEditBtm_Ppl.ZOrder=0;
      gEditBtm_Hsp.ZOrder=0;
      gEditBtm_Set.ZOrder=0;          
    }    
    // PeopleTab
    else if (mouse.x >= 151 && mouse.x <= 180) {
      gEditBtm_Tile.ZOrder=0;
      gEditBtm_Itm.ZOrder=0;
      gEditBtm_Obj.ZOrder=0;
      gEditBtm_Nmy.ZOrder=0;
      gEditBtm_Ppl.ZOrder=2;
      gEditBtm_Hsp.ZOrder=0;
      gEditBtm_Set.ZOrder=0;        
    }
    // HotspotsTab
    else if (mouse.x >= 183 && mouse.x <= 221) {
      gEditBtm_Tile.ZOrder=0;
      gEditBtm_Itm.ZOrder=0;
      gEditBtm_Obj.ZOrder=0;
      gEditBtm_Nmy.ZOrder=0;
      gEditBtm_Ppl.ZOrder=0;
      gEditBtm_Hsp.ZOrder=2;
      gEditBtm_Set.ZOrder=0;        
    }
    // Settings
    else if (mouse.x >= 224 && mouse.x <= 280) {
      gEditBtm_Tile.ZOrder=0;
      gEditBtm_Itm.ZOrder=0;
      gEditBtm_Obj.ZOrder=0;
      gEditBtm_Nmy.ZOrder=0;
      gEditBtm_Ppl.ZOrder=0;
      gEditBtm_Hsp.ZOrder=0;
      gEditBtm_Set.ZOrder=2;        
    }
  }
  if (GUI.GetAtScreenXY(mouse.x, mouse.y)== gEditBtm_Tile){
    toolMode = ToolMode_Tile;
    handleInterfaceClickEditTile();
  }
  else if (GUI.GetAtScreenXY(mouse.x, mouse.y)== gEditBtm_Itm){
    toolMode = ToolMode_Item;
    handleInterfaceClickEditItem();
  }
  else if (GUI.GetAtScreenXY(mouse.x, mouse.y)== gEditBtm_Obj){
    toolMode = ToolMode_Object;
    handleInterfaceClickEditObject();
  }
  else if (GUI.GetAtScreenXY(mouse.x, mouse.y)== gEditBtm_Nmy){
    toolMode = ToolMode_Enemy;
    handleInterfaceClickEditEnemy();
  }   
  else if (GUI.GetAtScreenXY(mouse.x, mouse.y)== gEditBtm_Ppl){
    toolMode = ToolMode_People;
    handleInterfaceClickEditPeople();
  }
  else if (GUI.GetAtScreenXY(mouse.x, mouse.y)== gEditBtm_Hsp){
    toolMode = ToolMode_Hotspot;
    handleInterfaceClickEditHotspot();
  }
  else if (GUI.GetAtScreenXY(mouse.x, mouse.y)== gEditBtm_Set){
    toolMode = ToolMode_Settings;    
  }
 
}



//*******************************************************************************
//* renderEditorTiles
//*
//*******************************************************************************
void renderEditorTiles() {
  int tilearea_x = 258;
  int tilearea_y = 89;
  int i, j, k=0;
  int tileCount;
  int tile_idx=0;
  DrawingSurface *surface = editorBuffer.GetDrawingSurface();
  DynamicSprite *bg_tilesquare = DynamicSprite.Create(tilearea_x, tilearea_y, false);
  DrawingSurface *bg_tilesquaresurf = bg_tilesquare.GetDrawingSurface();
  bg_tilesquaresurf.DrawImage(0, 0, 670);
  bg_tilesquaresurf.Release();
  surface.Clear();
 
  surface.DrawingColor = 14830;
  surface.DrawRectangle(50, 1, tilearea_x+50, tilearea_y);
  surface.DrawImage(51, 2, bg_tilesquare.Graphic, 0, tilearea_x-1, tilearea_y-2);
  //surface.DrawingColor = COLOR_TRANSPARENT;
  //surface.DrawRectangle(51, 2, tilearea_x+49, tilearea_y-1);
  
  // Count valid Tiles
  while (i<NUM_MAX_SPRITES) {
    if (tile_sprites[i].spr != null) tileCount++;
    i++;
  }
  
  // Calc Tiles fit per Row and col 
  tilesPerRow = FloatToInt( IntToFloat(tilearea_x)/ IntToFloat(size_tile_x+1), eRoundDown);
  tilesPerCol = FloatToInt( IntToFloat(tilearea_y)/ IntToFloat(size_tile_y+1), eRoundDown);
  // how many rows are needed for all tiles
  rows_needed = FloatToInt(IntToFloat(tileCount) / IntToFloat(tilesPerRow), eRoundUp);
  
  i=1;
  j=scroll_from;
  scroll_to = rows_needed - tilesPerCol - scroll_from +1;
  
  if (scroll_to > rows_needed) scroll_to = 0;
    //Need Y-scrolling, draw downarrow    
  if (scroll_to > 0) {
    surface.DrawImage(311,79,351);
    scrollDownActive = true;
  }
  else scrollDownActive =false;
  
  if (scroll_from > 1 ) {
    surface.DrawImage(311, 3,350);
    scrollUpActive = true;
  }
  else scrollUpActive =false;
  
  //columns
  while (j<=rows_needed - scroll_to) {
    //rows
    while (i<=tilesPerRow) {
      tile_idx = ((j-1) * tilesPerRow)+i;  
      if (tile_idx<=tileCount && tile_sprites[tile_idx].spr !=null) {
        if (selected_tile == tile_idx) {
          surface.DrawingColor = 15;
          surface.DrawRectangle (50+i+((i-1)*size_tile_x),2+k+(k * size_tile_y),51+i+((i-1)*size_tile_x)+size_tile_x,3+k+(k * size_tile_y)+size_tile_y);
          surface.DrawImage(51+i+((i-1)*size_tile_x),3+k+(k * size_tile_y), tile_sprites[tile_idx].spr.Graphic);          
        }
        else {
          surface.DrawImage(51+i+((i-1)*size_tile_x),3+k+(k * size_tile_y), tile_sprites[tile_idx].spr.Graphic);
        }
      }
      i++;
    }
    i=1;
    k++;
    j++;
  }
  // Layer FB/BG button
  if (layer==0) surface.DrawImage(2, 3, 333);
  else surface.DrawImage(2, 3, 334);
  
  // Layer Visible Button
  if (show_tiles) surface.DrawImage(36, 3, 368);
  else surface.DrawImage(36, 3, 367);
  
  // edit button
  if (selected_tile > 0)
    surface.DrawImage(2, 75, 331);
  else surface.DrawImage(2, 75, 362);
  
  surface.Release();
  btnEditTile.NormalGraphic = editorBuffer.Graphic;     
}

//*******************************************************************************
//* renderEditorItems
//*
//*******************************************************************************
void renderEditorItems() 
{
  int tilearea_x = 258;
  int tilearea_y = 41;
  int i, j, k=0;
  int itemCount;
  int item_idx=0;
  String itemident;
  ViewFrame *vf;
  DrawingSurface *surface = editorBuffer.GetDrawingSurface();
  surface.Clear();
  
  surface.DrawingColor = 59011;
  surface.DrawRectangle(50, 1, tilearea_x+50, tilearea_y);
  surface.DrawingColor = COLOR_TRANSPARENT;
  surface.DrawRectangle(51, 2, tilearea_x+49, tilearea_y-1);  

  // Count valid Tiles
  while (i<MAX_ITEMS) {
    if (item_types[i].loop != 0) itemCount++;
    i++;
  }
  itemCount+=3; //add Waypoint and Platforms
  
  // Calc Tiles fit per Row and col 
  tilesPerRow = FloatToInt( IntToFloat(tilearea_x)/ IntToFloat(size_tile_x+1), eRoundDown);
  tilesPerCol = FloatToInt( IntToFloat(tilearea_y)/ IntToFloat(size_tile_y+1), eRoundDown);
  // how many rows are needed for all tiles
  rows_needed = FloatToInt(IntToFloat(itemCount) / IntToFloat(tilesPerRow), eRoundUp);
  
  i=1;
  j=scroll_from;
  scroll_to = rows_needed - tilesPerCol - scroll_from +1;
  if (scroll_to > rows_needed) scroll_to = 0;
    //Need Y-scrolling, draw downarrow
  if (scroll_to > 0) {
    surface.DrawImage(311,29,351);
    scrollDownActive = true;
  }
  else scrollDownActive =false;
  
  if (scroll_from > 1 ) {
    surface.DrawImage(311, 3,350);
    scrollUpActive = true;
  }
  else scrollUpActive =false;
  
  //columns
  while (j<=rows_needed - scroll_to) {
    //rows
    while (i<=tilesPerRow) {
      item_idx = ((j-1) * tilesPerRow)+i; 

      if (item_idx<MAX_ITEMS && item_types[item_idx].loop !=0) {

        itemident = String.Format("%d",item_idx);
        vf = Game.GetViewFrame(tile_set.item_view, item_types[item_idx].loop, 0);
        if (selected_item == item_idx) {
          drawButton(surface, 51+i*2+((i-1)*size_tile_x),3+k+(k * size_tile_y),  size_tile_x, size_tile_y,59011, 58723, true, itemident, vf.Graphic);
        }
        else {
          drawButton(surface, 51+i*2+((i-1)*size_tile_x),3+k+(k * size_tile_y),  size_tile_x, size_tile_y,59011, 58723, false, itemident, vf.Graphic);
        }

      }
      i++;
    }
    i=1;
    k++;
    j++;
  }
  
  // Layer Visible Button
  if (show_items) surface.DrawImage(36, 3, 368);
  else surface.DrawImage(36, 3, 367);
  
  // Visibility Button
  if (item_hidden) surface.DrawImage(2, 11, 336);
  else  surface.DrawImage(2, 11, 352);
  
  surface.DrawingColor = 14830;
  surface.DrawRectangle(50, 45, tilearea_x+50, 48+Game.SpriteHeight[tile_set.platform_hori]+3);
  surface.DrawingColor = COLOR_TRANSPARENT;
  surface.DrawRectangle(51, 46, tilearea_x+49, 48+Game.SpriteHeight[tile_set.platform_hori]+2);  
  bool pform_hori_active = false;
  bool pform_vert_active = false;
  bool wpoint_stop_active =false;
  bool wpoint_up_active =false;
  bool wpoint_down_active =false;
  bool wpoint_left_active =false;
  bool wpoint_right_active =false;
  bool playerspawn_active =false;
  // Platforms 18917
  if (selected_item == -100) pform_hori_active = true;
  else if (selected_item == -101) pform_vert_active = true;
  else if (selected_item == -102) wpoint_stop_active = true;
  else if (selected_item == -103) playerspawn_active = true;
  else if (selected_item == -104) wpoint_up_active = true;
  else if (selected_item == -105) wpoint_down_active = true;
  else if (selected_item == -106) wpoint_left_active = true;
  else if (selected_item == -107) wpoint_right_active = true;
  drawButton(surface, 53, 48, Game.SpriteWidth[tile_set.platform_hori], Game.SpriteHeight[tile_set.platform_hori], 18917, 64458, pform_hori_active, "Plat Form horiz",tile_set.platform_hori);
  drawButton(surface, 55 +Game.SpriteWidth[tile_set.platform_vert], 48, Game.SpriteWidth[tile_set.platform_vert], Game.SpriteHeight[tile_set.platform_vert], 18917, 64458, pform_vert_active, "Plat Form vert",tile_set.platform_hori);
  drawButton(surface, 57 +Game.SpriteWidth[tile_set.platform_vert]*2, 48, Game.SpriteWidth[tile_set.platform_vert], Game.SpriteHeight[tile_set.platform_vert], 23420, 14830, playerspawn_active, "PlayerSpawn",358);
  drawButton(surface, 59 +Game.SpriteWidth[tile_set.platform_vert]*3, 48, Game.SpriteWidth[tile_set.platform_vert]-5, Game.SpriteHeight[tile_set.platform_vert], 19269, 15533, wpoint_stop_active, "Way Point Stop",0);
  drawButton(surface, 61 +Game.SpriteWidth[tile_set.platform_vert]*4-5, 48, Game.SpriteWidth[tile_set.platform_vert]-5, Game.SpriteHeight[tile_set.platform_vert], 19269, 15533, wpoint_up_active, "Way Point Up",0);
  drawButton(surface, 63 +Game.SpriteWidth[tile_set.platform_vert]*5-10, 48, Game.SpriteWidth[tile_set.platform_vert]-5, Game.SpriteHeight[tile_set.platform_vert], 19269, 15533, wpoint_down_active, "Way Point Down",0);
  drawButton(surface, 65 +Game.SpriteWidth[tile_set.platform_vert]*6-15, 48, Game.SpriteWidth[tile_set.platform_vert]-5, Game.SpriteHeight[tile_set.platform_vert], 19269, 15533, wpoint_left_active, "Way Point Left",0);
  drawButton(surface, 67 +Game.SpriteWidth[tile_set.platform_vert]*7-20, 48, Game.SpriteWidth[tile_set.platform_vert]-5, Game.SpriteHeight[tile_set.platform_vert], 19269, 15533, wpoint_right_active, "Way Point Right",0);

  surface.Release();
  btnEditItem.NormalGraphic = editorBuffer.Graphic; 
  
}


//*******************************************************************************
//* renderEditorObjects
//*
//*******************************************************************************
void renderEditorObjects() 
{
  int tilearea_x = 258;
  int tilearea_y = 89;
  int i, j, k=0;
  int gap;
  int objectCount;
  int obj_idx=0;

  String itemident;
  ViewFrame *vf;
  int sprite_slot;
  DrawingSurface *surface = editorBuffer.GetDrawingSurface();
  surface.Clear();
  
  surface.DrawingColor = 56196;
  surface.DrawRectangle(50, 1, tilearea_x+50, tilearea_y);
  surface.DrawingColor = COLOR_TRANSPARENT;
  surface.DrawRectangle(51, 2, tilearea_x+49, tilearea_y-1);  
  
  // Count valid Tiles
  while (i<MAX_ITEMS) {
    if (t_object_id[i] > 0) objectCount++;
    //Find gaps
    j=0;
    if (t_object_id[i] == 0){
      while (j<MAX_ITEMS) {
        if (i+j < MAX_ITEMS && t_object_id[i+j] >0) gap++;
        j++;
      }
    }    
    i++;
  }
  // Calc Tiles fit per Row and col 
  tilesPerRow = FloatToInt( IntToFloat(tilearea_x)/ IntToFloat(size_tile_x+2), eRoundDown);
  tilesPerCol = FloatToInt( IntToFloat(tilearea_y)/ IntToFloat(size_tile_y+2), eRoundDown);
  // how many rows are needed for all tiles
  rows_needed = FloatToInt(IntToFloat(objectCount+gap) / IntToFloat(tilesPerRow), eRoundUp);

  i=1;
  j=scroll_from;
  scroll_to = rows_needed - tilesPerCol - scroll_from +1;
  if (scroll_to < rows_needed) scroll_to = 0;
  
    //Need Y-scrolling, draw downarrow
  if (scroll_to > 0) {
    surface.DrawImage(311,29,351);
    scrollDownActive = true;
  }
  else scrollDownActive =false;
  
  if (scroll_from > 1 ) {
    surface.DrawImage(311, 3,350);
    scrollUpActive = true;
  }
  else scrollUpActive =false;
  
  //columns
  while (j<=rows_needed - scroll_to) {
    //rows
    while (i<=tilesPerRow) {
      obj_idx = ((j-1) * tilesPerRow)+i; 

      if (obj_idx<MAX_ITEMS && t_object_id[i]>0) {
        
        itemident = String.Format("%d",obj_idx);
        sprite_slot = item[t_object_id[i]].obj_sprite;
        
        if (selected_object == obj_idx) {
          drawButton(surface, 51+i*2+((i-1)*size_tile_x),3+k*2+(k * size_tile_y),  size_tile_x, size_tile_y,58723, 56196, true, itemident, sprite_slot);
        }
        else {
          drawButton(surface, 51+i*2+((i-1)*size_tile_x),3+k*2+(k * size_tile_y),  size_tile_x, size_tile_y,58723, 56196, false, itemident, sprite_slot);
        }
      }
      i++;
    }
    i=1;
    k++;
    j++;
    
  }
  
  // Layer Visible Button
  if (show_objects) surface.DrawImage(36, 3, 368);
  else surface.DrawImage(36, 3, 367);  
  // edit button
  surface.DrawImage(2, 72, 354);
  if (selected_object > 0) {
    surface.DrawImage(20, 72, 331);
    surface.DrawImage(2, 81, 355);
  }
  else {
    surface.DrawImage(20, 72, 362);
    surface.DrawImage(2, 81, 363);
  }  
  
  surface.Release();
  btnEditObject.NormalGraphic = editorBuffer.Graphic; 
}

//*******************************************************************************
//* renderEditorEnemy
//*
//*******************************************************************************
void renderEditorEnemy() 
{
  int tilearea_x = 258;
  int tilearea_y = 89;
  int i, j, k=0;
  int ppl_idx=0;
  int enemycount =0;
  String peopleident;
  ViewFrame *vf;
  int sprite_slot;
  DrawingSurface *surface = editorBuffer.GetDrawingSurface();
  surface.Clear();
  
  surface.DrawingColor = 13453;
  surface.DrawRectangle(50, 1, tilearea_x+50, tilearea_y);
  surface.DrawingColor = COLOR_TRANSPARENT;
  surface.DrawRectangle(51, 2, tilearea_x+49, tilearea_y-1);  
  

  // Count Enemies
  while (i<MAX_PEOPLE) {
    if (people_types[i].name != null) enemycount++;
    i++;
  } 
  i =0;
  
  
  // Calc Tiles fit per Row and col 
  tilesPerRow = FloatToInt( IntToFloat(tilearea_x)/ IntToFloat(size_tile_x+2), eRoundDown);
  tilesPerCol = FloatToInt( IntToFloat(tilearea_y)/ IntToFloat(size_tile_y+2), eRoundDown);
  // how many rows are needed for all tiles
  rows_needed = FloatToInt(IntToFloat(enemycount) / IntToFloat(tilesPerRow), eRoundUp);

  i=1;
  j=scroll_from;
  scroll_to = rows_needed - tilesPerCol - scroll_from +1;
  if (scroll_to >rows_needed) scroll_to = 0; 
  
    //Need Y-scrolling, draw downarrow
  if (scroll_to > 0) {
    surface.DrawImage(311,29,351);
    scrollDownActive = true;
  }
  else scrollDownActive =false;
  
  if (scroll_from > 1 ) {
    surface.DrawImage(311, 3,350);
    scrollUpActive = true;
  }
  else scrollUpActive =false;
  
  
  //enemies
  while (j<=rows_needed - scroll_to) {
    //rows
    while (i<=tilesPerRow) {
      ppl_idx = ((j-1) * tilesPerRow)+i+1; 
      if (ppl_idx < MAX_PEOPLE && people_types[ppl_idx].name != null) {
        peopleident = String.Format("%d",ppl_idx-1);
        if (people_types[ppl_idx].view >0) {
          vf = Game.GetViewFrame(people_types[ppl_idx].view, 0, 0);  
          sprite_slot = vf.Graphic;
        }
        else sprite_slot =0;      
        if (selected_enemy == ppl_idx) {
          drawButton(surface, 51+i*2+((i-1)*size_tile_x),3+k*2+(k * size_tile_y),  size_tile_x, size_tile_y,13072, 43398, true, peopleident, sprite_slot);
        }
        else {
          drawButton(surface, 51+i*2+((i-1)*size_tile_x),3+k*2+(k * size_tile_y),  size_tile_x, size_tile_y,13072, 43398, false, peopleident, sprite_slot);
        }         
      }
      i++;
    }
    i=1;
    j++;
    k++;
  }
  btnEditNmy.NormalGraphic = editorBuffer.Graphic;
}

//*******************************************************************************
//* renderEditorPeople
//*
//*******************************************************************************
void renderEditorPeople() 
{
  int tilearea_x = 258;
  int tilearea_y = 89;
  int i, j, k=0;
  int gap;
  int peopleCount;
  int ppl_idx=0;
  
  String peopleident;
  ViewFrame *vf;
  int sprite_slot;
  DrawingSurface *surface = editorBuffer.GetDrawingSurface();
  surface.Clear();
  
  surface.DrawingColor = 13453;
  surface.DrawRectangle(50, 1, tilearea_x+50, tilearea_y);
  surface.DrawingColor = COLOR_TRANSPARENT;
  surface.DrawRectangle(51, 2, tilearea_x+49, tilearea_y-1);  
  i =0;
  
  // Count NPCs
  //people_id[ppl_idx]
  while (i<MAX_PEOPLE) {
    if (people_id[i]>0) peopleCount++;
    //Find gaps
    j=0;
    if (people_id[i] == 0){
      while (j<MAX_PEOPLE) {
        if (i+j < MAX_PEOPLE && people_id[i+j] >0) gap++;
        j++;
      }
    }      
    i++;
  }   
  
  // Calc Tiles fit per Row and col 
  tilesPerRow = FloatToInt( IntToFloat(tilearea_x)/ IntToFloat(size_tile_x+2), eRoundDown);
  tilesPerCol = FloatToInt( IntToFloat(tilearea_y)/ IntToFloat(size_tile_y+2), eRoundDown);
  // how many rows are needed for all tiles
  rows_needed = FloatToInt(IntToFloat(peopleCount+gap) / IntToFloat(tilesPerRow), eRoundUp);

  i=1;
  j=scroll_from;
  scroll_to = rows_needed - tilesPerCol - scroll_from +1;
  if (scroll_to<rows_needed) scroll_to = 0;
  
    //Need Y-scrolling, draw downarrow
  if (scroll_to > 0) {
    surface.DrawImage(311,29,351);
    scrollDownActive = true;
  }
  else scrollDownActive =false;
  
  if (scroll_from > 1 ) {
    surface.DrawImage(311, 3,350);
    scrollUpActive = true;
  }
  else scrollUpActive =false;
  
  
  //NPCs
  i=1;
  j=scroll_from;
  k=0;

  //columns
  while (j<=rows_needed - scroll_to) {
    //rows
    while (i<=tilesPerRow) {
      ppl_idx = ((j-1) * tilesPerRow)+i; 
      if ( ppl_idx < MAX_PEOPLE && people_id[ppl_idx]>0 ) {
        peopleident = String.Format("%d",people[people_id[ppl_idx]].id);
        if (people[people_id[ppl_idx]].view >0 && people[ppl_idx].view < Game.ViewCount) {
          vf = Game.GetViewFrame(people[people_id[ppl_idx]].view, 0, 0);  
          sprite_slot = vf.Graphic;
        }
        else sprite_slot =0;
        
        if (selected_npc == people_id[ppl_idx]) {
          drawButton(surface, 51+i*2+((i-1)*size_tile_x),3+k*2+(k * size_tile_y), size_tile_x, size_tile_y,13072, 28134, true, peopleident, sprite_slot);
        }
        else {
          drawButton(surface, 51+i*2+((i-1)*size_tile_x),3+k*2+(k * size_tile_y), size_tile_x, size_tile_y,13072, 28134, false, peopleident, sprite_slot);
        }   

      }
      i++;
    }
    i=1;
    k++;
    j++;
    
  }
  
  // Layer Visible Button
  if (show_people) surface.DrawImage(36, 3, 368);
  else surface.DrawImage(36, 3, 367);  
  // edit button
  surface.DrawImage(2, 72, 359);
  if (selected_npc > -1) {
    surface.DrawImage(2, 81, 331);
    surface.DrawImage(20, 81, 355);
  }
  else  {
    surface.DrawImage(2, 81, 362);
    surface.DrawImage(20, 81, 363);
  }

  surface.Release();
  btnEditPeople.NormalGraphic = editorBuffer.Graphic; 
}



//*******************************************************************************
//* renderEditorHotspots
//*
//*******************************************************************************
void renderEditorHotspots() 
{
  int tilearea_x = 258;
  int tilearea_y = 89;
  int i, j, k=0;
  int gap;
  int hotspotCount;
  int hsp_idx=0;

  String hspident;
  DrawingSurface *surface = editorBuffer.GetDrawingSurface();
  surface.Clear();
  
  surface.DrawingColor = 43398;
  surface.DrawRectangle(50, 1, tilearea_x+50, tilearea_y);
  surface.DrawingColor = COLOR_TRANSPARENT;
  surface.DrawRectangle(51, 2, tilearea_x+49, tilearea_y-1);  
  
  // Count valid Tiles
  while (i<MAX_HOTSPOTS) {
    if (t_hotspot_id[i] > 0) hotspotCount++;
    //Find gaps
    j=0;
    if (t_hotspot_id[i] == 0){
      while (j<MAX_HOTSPOTS) {
        if (i+j < MAX_HOTSPOTS && t_hotspot_id[i+j] >0) gap++;
        j++;
      }
    }
    i++;
  }
  
  
  // Calc Tiles fit per Row and col 
  tilesPerRow = FloatToInt( IntToFloat(tilearea_x)/ IntToFloat(size_tile_x+2), eRoundDown);
  tilesPerCol = FloatToInt( IntToFloat(tilearea_y)/ IntToFloat(size_tile_y+2), eRoundDown);
  // how many rows are needed for all tiles
  rows_needed = FloatToInt(IntToFloat(hotspotCount+gap) / IntToFloat(tilesPerRow), eRoundUp);

  i=1;
  j=scroll_from;
  scroll_to = rows_needed - tilesPerCol - scroll_from +1;
  if (scroll_to > rows_needed) scroll_to = 0;
  
    //Need Y-scrolling, draw downarrow
  if (scroll_to > 0) {
    surface.DrawImage(311,29,351);
    scrollDownActive = true;
  }
  else scrollDownActive =false;
  
  if (scroll_from > 1 ) {
    surface.DrawImage(311, 3,350);
    scrollUpActive = true;
  }
  else scrollUpActive =false;
  
  //columns
  
  while (j<=rows_needed - scroll_to) {
    //rows
    while (i<=tilesPerRow) {
      hsp_idx = ((j-1) * tilesPerRow)+i; 
      if (hsp_idx<MAX_HOTSPOTS && t_hotspot_id[hsp_idx]> 0) {
        
        hspident = String.Format("%d",hsp_idx);

        if (selected_hotspot == hsp_idx) {
          drawButton(surface, 51+i*2+((i-1)*size_tile_x),3+k*2+(k * size_tile_y),  size_tile_x, size_tile_y,47398, 58225, true, hspident, 0);
        }
        else {
          drawButton(surface, 51+i*2+((i-1)*size_tile_x),3+k*2+(k * size_tile_y),  size_tile_x, size_tile_y,47398, 58225, false, hspident, 0);
        }
      }
      i++;
    }
    i=1;
    k++;
    j++;
    
  }
  
  // Layer Visible Button
  if (show_hotspots) surface.DrawImage(36, 3, 368);
  else surface.DrawImage(36, 3, 367);  
  
  // edit button
  surface.DrawImage(2, 72, 354);
  if (selected_hotspot > 0) {
    surface.DrawImage(20, 72, 331);
    surface.DrawImage(2, 81, 355);
  }
  else {
    surface.DrawImage(20, 72, 362);
    surface.DrawImage(2, 81, 363);
  }
  surface.Release();
  btnEditHsp.NormalGraphic = editorBuffer.Graphic; 
}
//*******************************************************************************
//* renderInterface
//*
//*******************************************************************************
void renderInterface()
{
  //Draw Tiles 
  if (gEditBtm_Tile.Visible && gEditBtm_Tile.ZOrder==2) {
    if (frame_drop)renderEditorTiles();
  }
  else if (gEditBtm_Itm.Visible && gEditBtm_Itm.ZOrder==2) {
    if (frame_drop)renderEditorItems();
  }
  else if (gEditBtm_Obj.Visible && gEditBtm_Obj.ZOrder==2) {
    if (frame_drop)renderEditorObjects();
  }
  else if (gEditBtm_Nmy.Visible && gEditBtm_Nmy.ZOrder==2) {
    if (frame_drop)renderEditorEnemy();
  }  
  else if (gEditBtm_Ppl.Visible && gEditBtm_Ppl.ZOrder==2) {
    if (frame_drop)renderEditorPeople();
  } 
  else if (gEditBtm_Hsp.Visible && gEditBtm_Hsp.ZOrder==2) {
    if (frame_drop)renderEditorHotspots();
  }
}


//*******************************************************************************
//* update
//*
//*******************************************************************************
void update()
{
  doInterface();
  doGridSwitching();
  doTileFlip();
  doDropper();
	doMapOverview();
  
	if (GUI.GetAtScreenXY(mouse.x, mouse.y) == null) {
    CAM.handle_scrolling(true);
    handleWorldClick();
  }
	else if ((isLeftMouseButtonDown && !mouse.IsButtonDown(eMouseLeft)|| 
      (isRightMouseButtonDown && !mouse.IsButtonDown(eMouseRight))) && GUI.GetAtScreenXY(mouse.x, mouse.y) == gEditBtm_Tile) handleInterfaceClick();
	
  else if (isLeftMouseButtonDown && !mouse.IsButtonDown(eMouseLeft) && GUI.GetAtScreenXY(mouse.x, mouse.y) == gEditBtm_Itm) handleInterfaceClick();
  
	else if ((isLeftMouseButtonDown && !mouse.IsButtonDown(eMouseLeft)|| 
          (isRightMouseButtonDown && !mouse.IsButtonDown(eMouseRight))) && GUI.GetAtScreenXY(mouse.x, mouse.y) == gEditBtm_Obj) handleInterfaceClick();
 
  else if (isLeftMouseButtonDown && !mouse.IsButtonDown(eMouseLeft) && GUI.GetAtScreenXY(mouse.x, mouse.y) == gEditBtm_Nmy)handleInterfaceClick();           
	else if ((isLeftMouseButtonDown && !mouse.IsButtonDown(eMouseLeft)|| 
          (isRightMouseButtonDown && !mouse.IsButtonDown(eMouseRight))) && GUI.GetAtScreenXY(mouse.x, mouse.y) == gEditBtm_Ppl) handleInterfaceClick();
	else if ((isLeftMouseButtonDown && !mouse.IsButtonDown(eMouseLeft)|| 
          (isRightMouseButtonDown && !mouse.IsButtonDown(eMouseRight))) && GUI.GetAtScreenXY(mouse.x, mouse.y) == gEditBtm_Hsp) handleInterfaceClick();
	else if (isLeftMouseButtonDown && !mouse.IsButtonDown(eMouseLeft) && GUI.GetAtScreenXY(mouse.x, mouse.y) == gEditBtm_Set) {
    handleInterfaceClick();
  }
	
	isLeftMouseButtonDown = mouse.IsButtonDown(eMouseLeft);
	isRightMouseButtonDown = mouse.IsButtonDown(eMouseRight);
	isGridKeyDown = IsKeyPressed(eKeyG);
	isSpaceDown = IsKeyPressed(eKeySpace);
  isTileFlipXKeyDown = IsKeyPressed(eKeyX); 
  isTileFlipYKeyDown = IsKeyPressed(eKeyY); 
  isTabKeyDown = IsKeyPressed(eKeyTab);
  isDropperKeyDown = IsKeyPressed(eKeyE);
  
	isNewKeyDown = IsKeyPressed(eKeyN);
	isLoadKeyDown = IsKeyPressed(eKeyL);
	isSaveKeyDown = IsKeyPressed(eKeyS);
	isResizeKeyDown = IsKeyPressed(eKeyR);

}


//*******************************************************************************
//* renderScene
//*
//*******************************************************************************
void renderScene()
{ 
  //those painting on the Room background
  if (!frame_drop) PARALLAX.draw_parallax();
  if (!frame_drop && show_tiles)  TILES.draw_tiles(true,drawGrid); 
  else {
    DrawingSurface *foregroundSurface = Foreground.GetDrawingSurface();
    foregroundSurface.Clear(COLOR_TRANSPARENT);
    foregroundSurface.Release();
    
  }
  if (show_items)  {
    if (show_objects) ITM.show_items_editor(false);
    else ITM.show_items_editor(false, true);
    PFORM.handle_platforms(true);
    WPOINT.show_waypoints_editor();    
  }
  
  if (show_objects && !show_items) {
    ITM.show_items_editor(true);
  }
  
  if (show_people) PEOPLE.handle_people(true);
  EGO.show_spawn_editor();

  if (show_hotspots) HSP.show_hotspots_editor();
  if (show_map) TILES.draw_map();
  if (frame_drop) {
    PARALLAX.handle_parallax();
    TILES.handle_anisync_tiles();
    
    DrawingSurface *surface = sceneBuffer.GetDrawingSurface();
    surface.Clear();

    if ((toolMode != 0 && toolMode!= ToolMode_Settings && !(toolMode == ToolMode_Tile && mouse.Mode!=eModeDropper && selected_tile ==0 && brush_max_idx==0)) && GUI.GetAtScreenXY(mouse.x, mouse.y) == null)
    // draw tile drawing rectangle
    {  
      int x1, y1, x2, y2;
      
      //draw brush rectangle
      if (brush_max_idx > 0 && toolMode == ToolMode_Tile) {
        x1 = TILES.getTileIndexXFromPoint(mouse.x, mouse.y) * size_tile_x + TILES.get_tile_offset_x();
        y1 = TILES.getTileIndexYFromPoint(mouse.x, mouse.y) * size_tile_y + TILES.get_tile_offset_y();
        x2 = x1 + (brush_dimx +1) * size_tile_x - 1;
        y2 = y1 + (brush_dimy +1) * size_tile_y - 1;           
      }
      else if ((mouse.IsButtonDown(eMouseLeft) && isLeftMouseButtonDown) || (mouse.IsButtonDown(eMouseRight) && isRightMouseButtonDown))
      // if we are currently dragging a tile rectangle
      {
        x1 = TILES.getTileIndexXFromPoint(toolBufferX, toolBufferY) * size_tile_x + TILES.get_tile_offset_x();
        y1 = TILES.getTileIndexYFromPoint(toolBufferX, toolBufferY) * size_tile_y + TILES.get_tile_offset_y();
        x2 = TILES.getTileIndexXFromPoint(mouse.x, mouse.y) * size_tile_x + TILES.get_tile_offset_x() + size_tile_x;
        y2 = TILES.getTileIndexYFromPoint(mouse.x, mouse.y) * size_tile_y + TILES.get_tile_offset_y() + size_tile_y;
        
        if (x1 > x2 - 1)
        {
          x1 += size_tile_x;
          x2 -= size_tile_x;
        }
        
        if (y1 > y2 - 1)
        {
          y1 += size_tile_y;
          y2 -= size_tile_y;
        }
        
      }
      else 
      // if we are not dragging a rectangle
      {
        // draw the tile rectangle over the mouse tile
        x1 = TILES.getTileIndexXFromPoint(mouse.x, mouse.y) * size_tile_x + TILES.get_tile_offset_x();
        y1 = TILES.getTileIndexYFromPoint(mouse.x, mouse.y) * size_tile_y + TILES.get_tile_offset_y();
        x2 = x1 + size_tile_x - 1;
        y2 = y1 + size_tile_y - 1;
      }
      
      if      (toolMode == ToolMode_Tile && brush_max_idx == 0) surface.DrawingColor = 15;
      else if (toolMode == ToolMode_Tile && brush_max_idx > 0) surface.DrawingColor = 52959;
      else if (toolMode == ToolMode_Item)   surface.DrawingColor = 65423;
      else if (toolMode == ToolMode_Object) surface.DrawingColor = 64975;
      else if (toolMode == ToolMode_Enemy)  surface.DrawingColor = 51189;
      else if (toolMode == ToolMode_People) surface.DrawingColor = 50997;
      else if (toolMode == ToolMode_Hotspot) surface.DrawingColor = 49114;
      
      //surface.DrawingColor = 15;
      //Brush Preview
      if (toolMode == ToolMode_Tile && mouse.Mode!=eModeDropper && selected_tile ==0 && brush_max_idx>0) {
          int brush_y = 0; 
          int brush_x  = 0;
          int idx = 0;
          
          while (brush_y <= brush_dimy) {
            brush_x= 0;
            while ( brush_x <= brush_dimx) {
              if (brush[idx].spr != null) surface.DrawImage(x1 + brush_x * size_tile_x, y1 + brush_y*size_tile_y, brush[idx].spr.Graphic);
              idx ++;
              brush_x++;
            }
            brush_y++;  
          }
      }
      surface.DrawLine(x1, y1, x1, y2);
      surface.DrawLine(x1, y2, x2, y2);

      
      surface.DrawLine(x2, y2, x2, y1);
      surface.DrawLine(x2, y1, x1, y1);

    }
    
    surface.DrawingColor=15;
    String currentile = String.Format ("Tile: %d",current_tile);
    //mirror_tile_x,  mirror_tile_y;
    if (mirror_tile_x) currentile = currentile.Append(" <X>");
    if (mirror_tile_y) currentile = currentile.Append(" <Y>");
    surface.DrawString(2, Screen.Height-10, eFontTinyOut, currentile);
    surface.Release();
    gEditorScene.BackgroundGraphic = sceneBuffer.Graphic;     
  }

  frame_drop = !frame_drop;
}


//*******************************************************************************
//* room_Leave
//*
//*******************************************************************************
function room_Leave()
{
	mouse.Visible = false;
	sceneBuffer.Delete();
	editorBuffer.Delete();
  gEditorScene.Visible=false;
}


//*******************************************************************************
//* room_RepExec
//*
//*******************************************************************************
function room_RepExec()
{
  current_tile = TILES.get_tile_at  ( mouse.x ,mouse.y, 1, ego_stats.current_tile);
  if (current_tile > 0) ego_stats.current_tile = current_tile;  
  update();

  if (levelLoaded ) {
    renderInterface();
    renderScene();
  }
}


//*******************************************************************************
//* on_call
//*
//*******************************************************************************
function on_call(editorAction action) 
{
  // Edit Tile
  if (action == editorAction_SetTile) {
    String newTileCodeString = String.Format("%02d%d%02d",tbxSetTileLoop.Text.AsInt, lblSetTileAnisync.Text.AsInt, lbxSetTileType.SelectedIndex);
    int newTileCode = newTileCodeString.AsInt;
    tile_sprites[selected_tile].code = newTileCode;
    // Updating the info fields with tilecode
    int type = TILES.split_tilecode (eCodepartAttrib, newTileCode);
    int loop = TILES.split_tilecode (eCodepartLoop, newTileCode);
    int sync = TILES.split_tilecode (eCodepartFlag, newTileCode);
    lblEditTileType.Text=String.Format("%d",type);
    lblEditTileLoop.Text=String.Format("%d",loop);
    if (sync >0) lblEditAnisync.Text= "yes";
    else lblEditAnisync.Text="no";
    lblEditTypeName.Text = TILES.get_tiletype_name(type);            
  }
  // New & Edit Object
  else if (action == editorAction_EditObject || action == editorAction_NewObject) {
    int new_obj_idx;
    if (action == editorAction_NewObject) {
      new_obj_idx = ITM.spawn_object(-1);
      selected_object = new_obj_idx;
    }
    else new_obj_idx = selected_object;
    item[ t_object_id[new_obj_idx] ].name           = tbxSetObjectName.Text;
    item[ t_object_id[new_obj_idx] ].shown_name     = tbxSetObjectShownName.Text;
    item[ t_object_id[new_obj_idx] ].obj_sprite     = tbxSetObjSprite.Text.AsInt;
    item[ t_object_id[new_obj_idx] ].is_solid       = lblSetObjIsSolid.Text.AsInt;
    item[ t_object_id[new_obj_idx] ].in_foreground  = lblSetObjIsFG.Text.AsInt;
    item[ t_object_id[new_obj_idx] ].usable         = lblSetObjAct.Text.AsInt;
    item[ t_object_id[new_obj_idx] ].ignore_gravity = lblSetObjGravity.Text.AsInt;
    lblEditObjName.Text = tbxSetObjectName.Text;
    lblEditObjAct.Text = lblSetObjActInfo.Text;
    lblEditObjIsSolid.Text = lblSetObjIsSolidInfo.Text;
    lblEditObjIsFG.Text    = lblSetObjIsFGInfo.Text;
    lblEditObjGravity.Text = lblSetObjGravityInfo.Text;
  }
  //editorAction_DelObject
  else if (action == editorAction_DelObject) {
    ITM.clear_item(t_object_id[selected_object]);
    selected_object = 0;
  }
  // New & Edit NPC
  else if (action == editorAction_EditNpc || action == editorAction_NewNpc) {
    int new_ppl_idx;
    String npc_name   = tbxSetNpcName.Text;
    int npc_view      = tbxSetNpcView.Text.AsInt;
    int npc_talkview  = tbxSetNpcTalkView.Text.AsInt;
    int npc_talkcolor = tbxSetNpcTalkColor.Text.AsInt;
    int npc_idleview  = tbxSetNpcIdleView.Text.AsInt;
    bool npc_interact = lblSetNpcAct.Text.AsInt;
    bool npc_hostile  = lblSetNpcHostile.Text.AsInt;
    
    if (npc_view > Game.ViewCount || npc_talkview > Game.ViewCount || npc_talkcolor > Game.ViewCount || npc_idleview > Game.ViewCount) {
      Display ("Invalid view number");
      return -1;
    }
    
    if (action == editorAction_NewNpc) {
      new_ppl_idx = PEOPLE.spawn_npc(-1, npc_name, npc_view, npc_talkview, npc_talkcolor, npc_idleview);
      people[new_ppl_idx].is_interactable = npc_interact;
      people[new_ppl_idx].is_hostile = npc_hostile;
      lblEditPplName.Text = tbxSetNpcName.Text;
      if (npc_interact) lblEditPplAct.Text = "yes";
      else  lblEditPplAct.Text = "no";
      selected_npc = new_ppl_idx;
    }
    else {
      new_ppl_idx = selected_npc;
      people[new_ppl_idx].name        = npc_name;
      people[new_ppl_idx].view        = npc_view;
      people[new_ppl_idx].talk_view   = npc_talkview;
      people[new_ppl_idx].talk_color  = npc_talkcolor;
      people[new_ppl_idx].idle_view   = npc_idleview;
      people[new_ppl_idx].is_interactable = npc_interact;
      people[new_ppl_idx].is_hostile      = npc_hostile;      
      people[new_ppl_idx].dead_timer      = -1;
      lblEditPplName.Text = tbxSetNpcName.Text;
      if (npc_interact) lblEditPplAct.Text = "yes";
      else  lblEditPplAct.Text = "no";      
      PEOPLE.update_people_char(new_ppl_idx);
    }
    
  }
  else if (action == editorAction_DelNpc) {
    PEOPLE.clear_people(selected_npc);
    selected_npc = 0;
  }
  // Edit Hotspot
  else if (action == editorAction_EditHsp) {
    HSP.set_hotspot_name(selected_hotspot, tbxSetHspName.Text);
    HSP.set_hotspot_shown_name(selected_hotspot, tbxSetHspShownName.Text);
    lblEditHspName.Text = tbxSetHspName.Text;
    
    if (lblSetHspHidden.Text.AsInt>0) {
      HSP.set_hotspot_hidden(selected_hotspot, true);
      lblEditHspHiddenInfo.Text = "yes";
      lblEditHspHidden.Text = "1";
    }
    else {
      HSP.set_hotspot_hidden(selected_hotspot, false);
      lblEditHspHiddenInfo.Text = "no";
      lblEditHspHidden.Text = "0";
    }
  }
  // New Hotspot
  else if (action == editorAction_NewHsp) {
    int is_hidden = lblSetHspHidden.Text.AsInt;
    int new_hsp_idx;
    new_hsp_idx = HSP.create_hotspot(-1, is_hidden, tbxSetHspName.Text);
    HSP.set_hotspot_shown_name(new_hsp_idx, tbxSetHspShownName.Text);    
    lblEditHspName.Text = tbxSetHspName.Text;
    if (lblSetHspHidden.Text.AsInt>0) {
      lblEditHspHiddenInfo.Text = "yes";
      lblEditHspHidden.Text = "1";
    }
    else {
      lblEditHspHiddenInfo.Text = "no";  
      lblEditHspHidden.Text = "0";  
    }
    selected_hotspot = new_hsp_idx;
  }
  // Delete all Hotspots of that ID
  else if (action == editorAction_DelHsp) {
    HSP.remove_hotspots_by_id(selected_hotspot);
    selected_hotspot = 0;
  }
  //Load Level
  else if (action == editorAction_LoadMap) {
    levelLoaded = false;
    TENG.clean_up();
    PARALLAX.default_parallax();
    String levelname = lbxEditSetLoad.Items[lbxEditSetLoad.SelectedIndex];
    levelname = levelname.Truncate(levelname.Length-4);
    leveledit = levelname;
    
    int new_tileset = tbxEditSetLoadTSet.Text.AsInt;
    if (new_tileset > 0) TILES.init_tile_sets(new_tileset);
    
    lblEditBtmTileSet.Text = String.Format("%d",TILES.get_tileset_number());    
    
    if (TENG.load_map(levelname, 0, 0, 0, true)) {
      lblEditBtmTilesprite.Text = String.Format("%d",tileset_sprite);
      levelLoaded = true;
    }
    
  }
  //Import Level
  else if (action == editorAction_ImportMap) {
    levelLoaded = false;
    TENG.clean_up();
    PARALLAX.default_parallax();
    String levelname = lbxEditSetImport.Items[lbxEditSetImport.SelectedIndex];
    levelname = levelname.Truncate(levelname.Length-4);
    tileset_sprite = tbxEditSetSpr.Text.AsInt;
    lblEditBtmTilesprite.Text = String.Format("%d",tileset_sprite);
    int new_tileset = tbxEditSetImportTSet.Text.AsInt;
    if (new_tileset > 0) TILES.init_tile_sets(new_tileset);
    lblEditBtmTileSet.Text = String.Format("%d",TILES.get_tileset_number());
    if (TENG.load_map_classic(levelname,16, 16, 145, 70, tbxEditSetSpr.Text.AsInt, false)) {
       TILES.update_tile_sprites(tileset_sprite);
       leveledit = "";
       levelLoaded = true;
    }
    
  }
  //Update Tiles from PM Level
  else if (action == editorAction_UpdateMap) {
    levelLoaded = false;
    TENG.stop();
    String levelname = lbxEditSetUpdate.Items[lbxEditSetUpdate.SelectedIndex];
    levelname = levelname.Truncate(levelname.Length-4);
    
    if (TENG.update_map_classic(levelname)) {
       leveledit = "";
       levelLoaded = true;
    }
  }   
  // Update Tilesprites
  else if (action == editorAction_SetTilesprite) {
    levelLoaded = false;
    TILES.update_tile_sprites(tileset_sprite);
    levelLoaded = true;
    lblEditBtmTilesprite.Text = String.Format("%d",tileset_sprite);
    lblEditBtmTileSet.Text = String.Format("%d",TILES.get_tileset_number());    
  }
  // New Map
  else if (action == editorAction_NewMap) {
    int new_tileset;
    int new_tilessprite;
    int new_size_x;
    int new_size_y;
    int new_tilesize;
    
    levelLoaded = false;
    TENG.clean_up();
    PARALLAX.default_parallax();
    new_tileset = tbxEditSetNewTset.Text.AsInt ;
    new_tilessprite = tbxEditSetNewSpr.Text.AsInt;
    new_size_x = tbxEditSetNewDimX.Text.AsInt ;
    new_size_y = tbxEditSetNewDimY.Text.AsInt ;
    new_tilesize = tbxEditSetNewTsize.Text.AsInt;
    
    if (new_tileset > 0) TILES.init_tile_sets(new_tileset);
    
    lblEditBtmTileSet.Text = String.Format("%d",TILES.get_tileset_number());    
    TENG.new_map(new_tilessprite, new_size_x, new_size_y, new_tilesize, new_tilesize);
    leveledit = "";
    levelLoaded = true;
  }
  // Save Map
  else if (action == editorAction_SaveMap) {
    int theslot = TENG.get_tile_strip_slot();
    String levelname = tbxEditSetSaveName.Text;
    levelname = levelname.Truncate(levelname.Length-4);
    if (TENG.save_map(levelname, theslot, true) ) {
      leveledit = levelname;
      Display ("Saved!");
    }
    
    
  }
}
function room_FirstLoad()
{
  
}
